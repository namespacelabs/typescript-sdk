// @generated by protoc-gen-es v1.3.0 with parameter "target=js+ts+dts"
// @generated from file proto/namespace/cloud/compute/v1beta/compute.proto (package namespace.cloud.compute.v1beta, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Label, LabelFilterEntry } from "../../../stdlib/labels_pb.js";
import { HttpCallbackEndpoint } from "../../../stdlib/callback_pb.js";
import { TimeSeries } from "../../../stdlib/timeseries_pb.js";
import { StringMatcher } from "../../../stdlib/matchers_pb.js";

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest
 */
export class CreateInstanceRequest extends Message<CreateInstanceRequest> {
  /**
   * The shape of the instance to be created.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceShape shape = 1;
   */
  shape?: InstanceShape;

  /**
   * A list of features that should be enabled in this instance.
   * Deprecated: use feature_configuration below instead.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.Feature features = 3;
   */
  features: CreateInstanceRequest_Feature[] = [];

  /**
   * A list of features that should be enabled in this instance.
   *
   * @generated from field: namespace.cloud.compute.v1beta.CreateInstanceRequest.FeatureConfiguration feature_configuration = 11;
   */
  featureConfiguration?: CreateInstanceRequest_FeatureConfiguration;

  /**
   * A human-facing description of the purpose of this instance. Used for
   * debugging purposes.
   *
   * @generated from field: string documented_purpose = 4;
   */
  documentedPurpose = "";

  /**
   * A set of labels that are attached to the new instance. Instances can be
   * queried based on labels, see also ListInstancesRequest.
   *
   * @generated from field: repeated namespace.stdlib.Label labels = 5;
   */
  labels: Label[] = [];

  /**
   * Timestamp of when this instance should be released (in UTC). Requested
   * deadlines can be modified by policy. For example, if a workspace is
   * configured with a maximum deadline of 24h, and a instance is created with
   * a requested deadline of 48h, the resulting instance will have a deadline
   * of 24h.
   *
   * When a instance hits its deadline, processes within will receive a
   * `SIGTERM` and have a maximum time to shutdown gracefully before the
   * instance is destroyed.
   *
   * Note: In JSON format, the Timestamp type is encoded as a string in the
   * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
   *
   * @generated from field: google.protobuf.Timestamp deadline = 6;
   */
  deadline?: Timestamp;

  /**
   * Deprecated and ignored; it used to allow creation queueing.
   *
   * @generated from field: bool interactive = 7;
   */
  interactive = false;

  /**
   * Requests that the new instance be created in the specified region.
   *
   * Typically a region is not set. In that case, the Namespace platform makes
   * a placement a decision on behalf of users based on the type of workload,
   * tenant policies and available global capacity.
   *
   * @generated from field: string region = 8;
   */
  region = "";

  /**
   * Start the specified containers as part of instance creation. Containers
   * are deployed to `containerd` directly. See ContainerRequest for more
   * details. Only supported on Linux platform.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.ContainerRequest containers = 9;
   */
  containers: ContainerRequest[] = [];

  /**
   * Start the specified applications on the instance without using
   * containerization. Only supported on macOS platform.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.ApplicationRequest applications = 14;
   */
  applications: ApplicationRequest[] = [];

  /**
   * A set of experimental features that should be attached to this instance.
   * Experimental features may be removed or modified at any time by the
   * Namespace team.
   *
   * @generated from field: namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures experimental = 10;
   */
  experimental?: CreateInstanceRequest_ExperimentalFeatures;

  /**
   * Attach storage to the instance, notably, cache volumes.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.VolumeRequest volumes = 12;
   */
  volumes: VolumeRequest[] = [];

  /**
   * Enable container caching. Container caching is only available on Linux.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerCache container_cache = 13;
   */
  containerCache?: ContainerCache;

  /**
   * We'll HTTP POST on this URL whenever the instance changes state. The body
   * of the post will be application/json with a serialized
   * InstanceEventMetadata.
   *
   * @generated from field: namespace.stdlib.HttpCallbackEndpoint http_event_callback = 15;
   */
  httpEventCallback?: HttpCallbackEndpoint;

  /**
   * Additional authenticated registries that can be targeted when pulling images.
   * The map key is the registry address.
   *
   * @generated from field: map<string, namespace.cloud.compute.v1beta.AdditionalRegistry> additional_registries = 16;
   */
  additionalRegistries: { [key: string]: AdditionalRegistry } = {};

  constructor(data?: PartialMessage<CreateInstanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "shape", kind: "message", T: InstanceShape },
    { no: 3, name: "features", kind: "enum", T: proto3.getEnumType(CreateInstanceRequest_Feature), repeated: true },
    { no: 11, name: "feature_configuration", kind: "message", T: CreateInstanceRequest_FeatureConfiguration },
    { no: 4, name: "documented_purpose", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "labels", kind: "message", T: Label, repeated: true },
    { no: 6, name: "deadline", kind: "message", T: Timestamp },
    { no: 7, name: "interactive", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "containers", kind: "message", T: ContainerRequest, repeated: true },
    { no: 14, name: "applications", kind: "message", T: ApplicationRequest, repeated: true },
    { no: 10, name: "experimental", kind: "message", T: CreateInstanceRequest_ExperimentalFeatures },
    { no: 12, name: "volumes", kind: "message", T: VolumeRequest, repeated: true },
    { no: 13, name: "container_cache", kind: "message", T: ContainerCache },
    { no: 15, name: "http_event_callback", kind: "message", T: HttpCallbackEndpoint },
    { no: 16, name: "additional_registries", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: AdditionalRegistry} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest {
    return new CreateInstanceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest {
    return new CreateInstanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest {
    return new CreateInstanceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceRequest | PlainMessage<CreateInstanceRequest> | undefined, b: CreateInstanceRequest | PlainMessage<CreateInstanceRequest> | undefined): boolean {
    return proto3.util.equals(CreateInstanceRequest, a, b);
  }
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.CreateInstanceRequest.Feature
 */
export enum CreateInstanceRequest_Feature {
  /**
   * @generated from enum value: FEATURE_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Enable Kubernetes in this instance.
   *
   * @generated from enum value: FEATURE_KUBERNETES = 1;
   */
  KUBERNETES = 1,

  /**
   * Automatically expose ingresses annotated with "kubernetes.namespace.so/expose: true"
   * as authenticated HTTP endpoints.
   *
   * @generated from enum value: FEATURE_KUBERNETES_INGRESS_MANAGER = 2;
   */
  KUBERNETES_INGRESS_MANAGER = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(CreateInstanceRequest_Feature)
proto3.util.setEnumType(CreateInstanceRequest_Feature, "namespace.cloud.compute.v1beta.CreateInstanceRequest.Feature", [
  { no: 0, name: "FEATURE_UNKNOWN" },
  { no: 1, name: "FEATURE_KUBERNETES" },
  { no: 2, name: "FEATURE_KUBERNETES_INGRESS_MANAGER" },
]);

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures
 */
export class CreateInstanceRequest_ExperimentalFeatures extends Message<CreateInstanceRequest_ExperimentalFeatures> {
  /**
   * A list of private features used to enable experimental behavior in a
   * instance.
   *
   * For more details chat with the Namespace team.
   *
   * @generated from field: repeated string private_feature = 1;
   */
  privateFeature: string[] = [];

  /**
   * Attach the specified disks as additional read-only volumes to the new
   * instance. Disks are specified as container image sources, which are
   * converted into a flattened filesystem that is then made available as
   * block storage that is attached to the VM that backs the instance.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Disk disks = 2;
   */
  disks: CreateInstanceRequest_ExperimentalFeatures_Disk[] = [];

  /**
   * Configure `containerd` with an additional set of shims.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.ContainerdShim containerd_shims = 3;
   */
  containerdShims: CreateInstanceRequest_ExperimentalFeatures_ContainerdShim[] = [];

  /**
   * Export a set of ports using a TLS frontend. Because TLS allows a
   * proxy to perform SNI-based routing, different services can be backed
   * by a single TLS ingress.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.TlsBackedPort tls_backed_ports = 4;
   */
  tlsBackedPorts: CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort[] = [];

  /**
   * Request that the following set of container images be prewarmed in
   * `containerd`. This is strictly best-effort.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.PrewarmContainerImage prewarm_container_images = 5;
   */
  prewarmContainerImages: CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage[] = [];

  /**
   * Return an equivalent workload identity token that identifies the
   * workload just created.
   *
   * @generated from field: bool return_workload_identity_token = 6;
   */
  returnWorkloadIdentityToken = false;

  /**
   * Register a wildcard domain for ingress directed at this new instance.
   *
   * @generated from field: bool enable_wildcard_domain = 7;
   */
  enableWildcardDomain = false;

  /**
   * Reach out to the Namespace team to learn more about this capability.
   * A union of these set of volumes and the volumes defined in
   * CreateInstanceRequest are used.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.VolumeRequest volumes = 8;
   */
  volumes: VolumeRequest[] = [];

  /**
   * Reach out to the Namespace team to learn more about this capability.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.DirectoryRequest ensure_directory = 9;
   */
  ensureDirectory: CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest[] = [];

  /**
   * Reach out to the Namespace team to learn more about this capability.
   *
   * @generated from field: string unique_tag = 10;
   */
  uniqueTag = "";

  /**
   * Reach out to the Namespace team to learn more about this capability.
   *
   * @generated from field: map<string, string> exported_unix_sockets = 11;
   */
  exportedUnixSockets: { [key: string]: string } = {};

  /**
   * Enable container caching.
   *
   * @generated from field: namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.ContainerCache container_cache = 12;
   */
  containerCache?: CreateInstanceRequest_ExperimentalFeatures_ContainerCache;

  /**
   * Hooks to trigger before any programs (containers or applications) are started.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook pre_start_hook = 17;
   */
  preStartHook: CreateInstanceRequest_ExperimentalFeatures_Hook[] = [];

  /**
   * Hooks to trigger before the instance shuts down.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook pre_shutdown_hook = 13;
   */
  preShutdownHook: CreateInstanceRequest_ExperimentalFeatures_Hook[] = [];

  /**
   * Public keys to enroll for SSH access to the created instance.
   *
   * @generated from field: repeated string authorized_ssh_keys = 14;
   */
  authorizedSshKeys: string[] = [];

  /**
   * Base image ID to use for a macOS instance.
   *
   * @generated from field: string macos_base_image_id = 16;
   */
  macosBaseImageId = "";

  /**
   * Reach out to the Namespace team to learn more about this capability.
   *
   * @generated from field: map<string, string> internal = 15;
   */
  internal: { [key: string]: string } = {};

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "private_feature", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "disks", kind: "message", T: CreateInstanceRequest_ExperimentalFeatures_Disk, repeated: true },
    { no: 3, name: "containerd_shims", kind: "message", T: CreateInstanceRequest_ExperimentalFeatures_ContainerdShim, repeated: true },
    { no: 4, name: "tls_backed_ports", kind: "message", T: CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort, repeated: true },
    { no: 5, name: "prewarm_container_images", kind: "message", T: CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage, repeated: true },
    { no: 6, name: "return_workload_identity_token", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "enable_wildcard_domain", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "volumes", kind: "message", T: VolumeRequest, repeated: true },
    { no: 9, name: "ensure_directory", kind: "message", T: CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest, repeated: true },
    { no: 10, name: "unique_tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "exported_unix_sockets", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 12, name: "container_cache", kind: "message", T: CreateInstanceRequest_ExperimentalFeatures_ContainerCache },
    { no: 17, name: "pre_start_hook", kind: "message", T: CreateInstanceRequest_ExperimentalFeatures_Hook, repeated: true },
    { no: 13, name: "pre_shutdown_hook", kind: "message", T: CreateInstanceRequest_ExperimentalFeatures_Hook, repeated: true },
    { no: 14, name: "authorized_ssh_keys", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 16, name: "macos_base_image_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "internal", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures {
    return new CreateInstanceRequest_ExperimentalFeatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures {
    return new CreateInstanceRequest_ExperimentalFeatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures {
    return new CreateInstanceRequest_ExperimentalFeatures().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceRequest_ExperimentalFeatures | PlainMessage<CreateInstanceRequest_ExperimentalFeatures> | undefined, b: CreateInstanceRequest_ExperimentalFeatures | PlainMessage<CreateInstanceRequest_ExperimentalFeatures> | undefined): boolean {
    return proto3.util.equals(CreateInstanceRequest_ExperimentalFeatures, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Disk
 */
export class CreateInstanceRequest_ExperimentalFeatures_Disk extends Message<CreateInstanceRequest_ExperimentalFeatures_Disk> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string image_ref = 2;
   */
  imageRef = "";

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_Disk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Disk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "image_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Disk {
    return new CreateInstanceRequest_ExperimentalFeatures_Disk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Disk {
    return new CreateInstanceRequest_ExperimentalFeatures_Disk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Disk {
    return new CreateInstanceRequest_ExperimentalFeatures_Disk().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_Disk | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_Disk> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_Disk | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_Disk> | undefined): boolean {
    return proto3.util.equals(CreateInstanceRequest_ExperimentalFeatures_Disk, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.ContainerdShim
 */
export class CreateInstanceRequest_ExperimentalFeatures_ContainerdShim extends Message<CreateInstanceRequest_ExperimentalFeatures_ContainerdShim> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string runtime_type = 2;
   */
  runtimeType = "";

  /**
   * @generated from field: repeated string add_to_path = 3;
   */
  addToPath: string[] = [];

  /**
   * @generated from field: string binary_name = 4;
   */
  binaryName = "";

  /**
   * @generated from field: string root = 5;
   */
  root = "";

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_ContainerdShim>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.ContainerdShim";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "runtime_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "add_to_path", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "binary_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_ContainerdShim {
    return new CreateInstanceRequest_ExperimentalFeatures_ContainerdShim().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_ContainerdShim {
    return new CreateInstanceRequest_ExperimentalFeatures_ContainerdShim().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_ContainerdShim {
    return new CreateInstanceRequest_ExperimentalFeatures_ContainerdShim().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_ContainerdShim | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_ContainerdShim> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_ContainerdShim | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_ContainerdShim> | undefined): boolean {
    return proto3.util.equals(CreateInstanceRequest_ExperimentalFeatures_ContainerdShim, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.TlsBackedPort
 */
export class CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort extends Message<CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: int32 port = 2;
   */
  port = 0;

  /**
   * If this is false, TLS is used in passthrough mode.
   *
   * @generated from field: bool terminate_tls = 3;
   */
  terminateTls = false;

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.TlsBackedPort";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "terminate_tls", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort {
    return new CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort {
    return new CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort {
    return new CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort> | undefined): boolean {
    return proto3.util.equals(CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.PrewarmContainerImage
 */
export class CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage extends Message<CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage> {
  /**
   * The target containerd that the image should be warmed up to. Use
   * "default" for containers started by Namespace; "moby" for Docker
   * containers and "k8s" for Kubernetes.
   *
   * @generated from field: string containerd_namespace = 1;
   */
  containerdNamespace = "";

  /**
   * A fully qualified image reference, including digest. Only fully
   * specified images will be part of optimized profiles. Non-fully
   * qualified references are silently dropped.
   *
   * @generated from field: string image_ref = 2;
   */
  imageRef = "";

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.PrewarmContainerImage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "containerd_namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "image_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage {
    return new CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage {
    return new CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage {
    return new CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage> | undefined): boolean {
    return proto3.util.equals(CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.DirectoryRequest
 */
export class CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest extends Message<CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest> {
  /**
   * @generated from field: string abs_path = 1;
   */
  absPath = "";

  /**
   * @generated from field: uint32 mode = 2;
   */
  mode = 0;

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.DirectoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "abs_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mode", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest {
    return new CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest {
    return new CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest {
    return new CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest> | undefined): boolean {
    return proto3.util.equals(CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest, a, b);
  }
}

/**
 * Deprecated: use the top-most message.
 *
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.ContainerCache
 */
export class CreateInstanceRequest_ExperimentalFeatures_ContainerCache extends Message<CreateInstanceRequest_ExperimentalFeatures_ContainerCache> {
  /**
   * Which cache volume to use to store container images.
   *
   * @generated from field: string cache_volume_tag = 1;
   */
  cacheVolumeTag = "";

  /**
   * If this is a separate volume, the size of the volume is required. Must not be set if this is an existing tag.
   *
   * @generated from field: int64 size_mb = 2;
   */
  sizeMb = protoInt64.zero;

  /**
   * If this is an existing volume (i.e. for which a volume request exists), the relative path within that volume to use. Optional.
   *
   * @generated from field: string relative_path = 3;
   */
  relativePath = "";

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_ContainerCache>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.ContainerCache";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cache_volume_tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "size_mb", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "relative_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_ContainerCache {
    return new CreateInstanceRequest_ExperimentalFeatures_ContainerCache().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_ContainerCache {
    return new CreateInstanceRequest_ExperimentalFeatures_ContainerCache().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_ContainerCache {
    return new CreateInstanceRequest_ExperimentalFeatures_ContainerCache().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_ContainerCache | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_ContainerCache> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_ContainerCache | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_ContainerCache> | undefined): boolean {
    return proto3.util.equals(CreateInstanceRequest_ExperimentalFeatures_ContainerCache, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook
 */
export class CreateInstanceRequest_ExperimentalFeatures_Hook extends Message<CreateInstanceRequest_ExperimentalFeatures_Hook> {
  /**
   * If set, execute this command during the hook.
   *
   * @generated from field: namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook.Command command = 1;
   */
  command?: CreateInstanceRequest_ExperimentalFeatures_Hook_Command;

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_Hook>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "command", kind: "message", T: CreateInstanceRequest_ExperimentalFeatures_Hook_Command },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Hook {
    return new CreateInstanceRequest_ExperimentalFeatures_Hook().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Hook {
    return new CreateInstanceRequest_ExperimentalFeatures_Hook().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Hook {
    return new CreateInstanceRequest_ExperimentalFeatures_Hook().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_Hook | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_Hook> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_Hook | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_Hook> | undefined): boolean {
    return proto3.util.equals(CreateInstanceRequest_ExperimentalFeatures_Hook, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook.Command
 */
export class CreateInstanceRequest_ExperimentalFeatures_Hook_Command extends Message<CreateInstanceRequest_ExperimentalFeatures_Hook_Command> {
  /**
   * @generated from field: string command = 1;
   */
  command = "";

  /**
   * A set of arguments to pass to the command invocation.
   *
   * Example: `["--foobar"]`
   *
   * @generated from field: repeated string args = 2;
   */
  args: string[] = [];

  /**
   * A set of environment values to be used as the command's environment.
   *
   * These set of environment variables are added in addition to a
   * system-specified set of environment variables.
   *
   * Example: `{"FOOBAR": "1"}`
   *
   * @generated from field: map<string, string> environment = 3;
   */
  environment: { [key: string]: string } = {};

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_Hook_Command>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook.Command";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "command", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "args", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "environment", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Hook_Command {
    return new CreateInstanceRequest_ExperimentalFeatures_Hook_Command().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Hook_Command {
    return new CreateInstanceRequest_ExperimentalFeatures_Hook_Command().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Hook_Command {
    return new CreateInstanceRequest_ExperimentalFeatures_Hook_Command().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_Hook_Command | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_Hook_Command> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_Hook_Command | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_Hook_Command> | undefined): boolean {
    return proto3.util.equals(CreateInstanceRequest_ExperimentalFeatures_Hook_Command, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.FeatureConfiguration
 */
export class CreateInstanceRequest_FeatureConfiguration extends Message<CreateInstanceRequest_FeatureConfiguration> {
  /**
   * If set, also runs a single-node Kubernetes in this instance. Must be
   * set to a specific Kubernetes major+minor version, e.g. "1.26" or "1.28".
   *
   * @generated from field: string enable_kubernetes_version = 1;
   */
  enableKubernetesVersion = "";

  /**
   * Automatically expose ingresses annotated with "kubernetes.namespace.so/expose: true"
   * as authenticated HTTP endpoints.
   *
   * @generated from field: bool enable_kubernetes_ingress_manager = 2;
   */
  enableKubernetesIngressManager = false;

  constructor(data?: PartialMessage<CreateInstanceRequest_FeatureConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.FeatureConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enable_kubernetes_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "enable_kubernetes_ingress_manager", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_FeatureConfiguration {
    return new CreateInstanceRequest_FeatureConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_FeatureConfiguration {
    return new CreateInstanceRequest_FeatureConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_FeatureConfiguration {
    return new CreateInstanceRequest_FeatureConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInstanceRequest_FeatureConfiguration | PlainMessage<CreateInstanceRequest_FeatureConfiguration> | undefined, b: CreateInstanceRequest_FeatureConfiguration | PlainMessage<CreateInstanceRequest_FeatureConfiguration> | undefined): boolean {
    return proto3.util.equals(CreateInstanceRequest_FeatureConfiguration, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AdditionalRegistry
 */
export class AdditionalRegistry extends Message<AdditionalRegistry> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator authentication = 1;
   */
  authentication?: AdditionalRegistry_Authenticator;

  constructor(data?: PartialMessage<AdditionalRegistry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AdditionalRegistry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authentication", kind: "message", T: AdditionalRegistry_Authenticator },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdditionalRegistry {
    return new AdditionalRegistry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdditionalRegistry {
    return new AdditionalRegistry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdditionalRegistry {
    return new AdditionalRegistry().fromJsonString(jsonString, options);
  }

  static equals(a: AdditionalRegistry | PlainMessage<AdditionalRegistry> | undefined, b: AdditionalRegistry | PlainMessage<AdditionalRegistry> | undefined): boolean {
    return proto3.util.equals(AdditionalRegistry, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator
 */
export class AdditionalRegistry_Authenticator extends Message<AdditionalRegistry_Authenticator> {
  /**
   * A pair of username and password to use when pulling images.
   *
   * @generated from field: namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.Basic basic = 1;
   */
  basic?: AdditionalRegistry_Authenticator_Basic;

  /**
   * Instruct Namespace to generate an OIDC token to access the registry.
   * The generated access token will be signed by the issuer `https://federation.namespaceapis.com`.
   *
   * @generated from field: namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.OpenIDFederation openid = 2;
   */
  openid?: AdditionalRegistry_Authenticator_OpenIDFederation;

  /**
   * Namespace will federate with AWS to obtain an [ECR authorization token](https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_GetAuthorizationToken.html).
   * Make sure to grant the required `ecr:*` permissions to the federated IAM role.
   *
   * @generated from field: namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.AssumeRoleFromAwsFederation ecr_token_from_aws_federation = 3;
   */
  ecrTokenFromAwsFederation?: AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation;

  constructor(data?: PartialMessage<AdditionalRegistry_Authenticator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "basic", kind: "message", T: AdditionalRegistry_Authenticator_Basic },
    { no: 2, name: "openid", kind: "message", T: AdditionalRegistry_Authenticator_OpenIDFederation },
    { no: 3, name: "ecr_token_from_aws_federation", kind: "message", T: AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdditionalRegistry_Authenticator {
    return new AdditionalRegistry_Authenticator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator {
    return new AdditionalRegistry_Authenticator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator {
    return new AdditionalRegistry_Authenticator().fromJsonString(jsonString, options);
  }

  static equals(a: AdditionalRegistry_Authenticator | PlainMessage<AdditionalRegistry_Authenticator> | undefined, b: AdditionalRegistry_Authenticator | PlainMessage<AdditionalRegistry_Authenticator> | undefined): boolean {
    return proto3.util.equals(AdditionalRegistry_Authenticator, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.Basic
 */
export class AdditionalRegistry_Authenticator_Basic extends Message<AdditionalRegistry_Authenticator_Basic> {
  /**
   * @generated from field: string username = 1;
   */
  username = "";

  /**
   * @generated from field: string password_secret_ref = 2;
   */
  passwordSecretRef = "";

  constructor(data?: PartialMessage<AdditionalRegistry_Authenticator_Basic>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.Basic";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "password_secret_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdditionalRegistry_Authenticator_Basic {
    return new AdditionalRegistry_Authenticator_Basic().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator_Basic {
    return new AdditionalRegistry_Authenticator_Basic().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator_Basic {
    return new AdditionalRegistry_Authenticator_Basic().fromJsonString(jsonString, options);
  }

  static equals(a: AdditionalRegistry_Authenticator_Basic | PlainMessage<AdditionalRegistry_Authenticator_Basic> | undefined, b: AdditionalRegistry_Authenticator_Basic | PlainMessage<AdditionalRegistry_Authenticator_Basic> | undefined): boolean {
    return proto3.util.equals(AdditionalRegistry_Authenticator_Basic, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.OpenIDFederation
 */
export class AdditionalRegistry_Authenticator_OpenIDFederation extends Message<AdditionalRegistry_Authenticator_OpenIDFederation> {
  /**
   * Required.
   *
   * @generated from field: string username = 1;
   */
  username = "";

  /**
   * Optional. If not set, the audience will be the address of the target registry.
   *
   * @generated from field: string audience = 2;
   */
  audience = "";

  constructor(data?: PartialMessage<AdditionalRegistry_Authenticator_OpenIDFederation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.OpenIDFederation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "audience", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdditionalRegistry_Authenticator_OpenIDFederation {
    return new AdditionalRegistry_Authenticator_OpenIDFederation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator_OpenIDFederation {
    return new AdditionalRegistry_Authenticator_OpenIDFederation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator_OpenIDFederation {
    return new AdditionalRegistry_Authenticator_OpenIDFederation().fromJsonString(jsonString, options);
  }

  static equals(a: AdditionalRegistry_Authenticator_OpenIDFederation | PlainMessage<AdditionalRegistry_Authenticator_OpenIDFederation> | undefined, b: AdditionalRegistry_Authenticator_OpenIDFederation | PlainMessage<AdditionalRegistry_Authenticator_OpenIDFederation> | undefined): boolean {
    return proto3.util.equals(AdditionalRegistry_Authenticator_OpenIDFederation, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.AssumeRoleFromAwsFederation
 */
export class AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation extends Message<AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation> {
  /**
   * Amazon Resource Name of the IAM role to assume.
   * The IAM role must be [set up for federated access from Namespace](https://namespace.so/docs/federation/aws#accessing-aws-resources-from-namespace) including an appropriate trust policy.
   *
   * @generated from field: string role_arn = 1;
   */
  roleArn = "";

  constructor(data?: PartialMessage<AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.AssumeRoleFromAwsFederation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "role_arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation {
    return new AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation {
    return new AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation {
    return new AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation().fromJsonString(jsonString, options);
  }

  static equals(a: AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation | PlainMessage<AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation> | undefined, b: AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation | PlainMessage<AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation> | undefined): boolean {
    return proto3.util.equals(AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation, a, b);
  }
}

/**
 * DescribeInstanceResponse is returned as a result to CreateInstance or
 * DescribeInstance. It includes both standard metadata (that focuses on
 * instance status), and extended metadata (credentials, endpoints, etc).
 *
 * @generated from message namespace.cloud.compute.v1beta.DescribeInstanceResponse
 */
export class DescribeInstanceResponse extends Message<DescribeInstanceResponse> {
  /**
   * A fully qualified URL that points to the instance summary in the
   * dashboard. E.g.
   * `https://cloud.namespace.so/01gr490qvbntkjn9jwypnd4g04/instance/ui3e3e3g7cfrg`.
   *
   * @generated from field: string instance_url = 1;
   */
  instanceUrl = "";

  /**
   * InstanceMetadata include both creation time specified fields such as
   * labels, and status-like properties like the destroyed timestamp if the
   * instance is no longer running.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata metadata = 2;
   */
  metadata?: InstanceMetadata;

  /**
   * Service-specific metadata which may include credentials. E.g. SSH or
   * Kubernetes endpoint information.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceExtendedMetadata extended_metadata = 3;
   */
  extendedMetadata?: InstanceExtendedMetadata;

  /**
   * Endpoint information of the private Container Registry that is usable
   * with this instance. Instances are pre-configured to access workspace-owned
   * images in this registry.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ImageRegistry registry = 4;
   */
  registry?: ImageRegistry;

  /**
   * If the instance creation specified a set of containers, specifies the
   * corresponding allocated containers.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.AllocatedContainer containers = 5;
   */
  containers: AllocatedContainer[] = [];

  /**
   * A set of experimental features attached to this instance. Experimental
   * features may be removed or modified at any time by the Namespace team.
   *
   * @generated from field: namespace.cloud.compute.v1beta.DescribeInstanceResponse.ExperimentalFeatures experimental = 6;
   */
  experimental?: DescribeInstanceResponse_ExperimentalFeatures;

  /**
   * A list of metadata that is attached to the instance.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.Attachment attachments = 7;
   */
  attachments: Attachment[] = [];

  /**
   * The instance's container cache configuration, if one exists.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerCache container_cache = 8;
   */
  containerCache?: ContainerCache;

  constructor(data?: PartialMessage<DescribeInstanceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.DescribeInstanceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata", kind: "message", T: InstanceMetadata },
    { no: 3, name: "extended_metadata", kind: "message", T: InstanceExtendedMetadata },
    { no: 4, name: "registry", kind: "message", T: ImageRegistry },
    { no: 5, name: "containers", kind: "message", T: AllocatedContainer, repeated: true },
    { no: 6, name: "experimental", kind: "message", T: DescribeInstanceResponse_ExperimentalFeatures },
    { no: 7, name: "attachments", kind: "message", T: Attachment, repeated: true },
    { no: 8, name: "container_cache", kind: "message", T: ContainerCache },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeInstanceResponse {
    return new DescribeInstanceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeInstanceResponse {
    return new DescribeInstanceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeInstanceResponse {
    return new DescribeInstanceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeInstanceResponse | PlainMessage<DescribeInstanceResponse> | undefined, b: DescribeInstanceResponse | PlainMessage<DescribeInstanceResponse> | undefined): boolean {
    return proto3.util.equals(DescribeInstanceResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.DescribeInstanceResponse.ExperimentalFeatures
 */
export class DescribeInstanceResponse_ExperimentalFeatures extends Message<DescribeInstanceResponse_ExperimentalFeatures> {
  /**
   * If a workload identity token was requested at creation time, it's
   * returned exclusively as part of the response to CreateInstance().
   *
   * @generated from field: string workload_identity_token = 1;
   */
  workloadIdentityToken = "";

  /**
   * If `enable_wildcard_certificate` is set, the certificate that is
   * being generated for this instance. E.g. `*.{instanceid}.foobar.com`.
   *
   * @generated from field: string instance_wildcard_domain = 2;
   */
  instanceWildcardDomain = "";

  constructor(data?: PartialMessage<DescribeInstanceResponse_ExperimentalFeatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.DescribeInstanceResponse.ExperimentalFeatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workload_identity_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "instance_wildcard_domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeInstanceResponse_ExperimentalFeatures {
    return new DescribeInstanceResponse_ExperimentalFeatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeInstanceResponse_ExperimentalFeatures {
    return new DescribeInstanceResponse_ExperimentalFeatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeInstanceResponse_ExperimentalFeatures {
    return new DescribeInstanceResponse_ExperimentalFeatures().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeInstanceResponse_ExperimentalFeatures | PlainMessage<DescribeInstanceResponse_ExperimentalFeatures> | undefined, b: DescribeInstanceResponse_ExperimentalFeatures | PlainMessage<DescribeInstanceResponse_ExperimentalFeatures> | undefined): boolean {
    return proto3.util.equals(DescribeInstanceResponse_ExperimentalFeatures, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerCache
 */
export class ContainerCache extends Message<ContainerCache> {
  /**
   * Which cache volume to use to store container images.
   *
   * @generated from field: string cache_volume_tag = 1;
   */
  cacheVolumeTag = "";

  /**
   * If this is a separate volume, the size of the volume is required. Must not be set if this is an existing tag.
   *
   * @generated from field: int64 size_mb = 2;
   */
  sizeMb = protoInt64.zero;

  /**
   * If this is an existing volume (i.e. for which a volume request exists), the relative path within that volume to use. Optional.
   *
   * @generated from field: string relative_path = 3;
   */
  relativePath = "";

  constructor(data?: PartialMessage<ContainerCache>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerCache";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cache_volume_tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "size_mb", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "relative_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerCache {
    return new ContainerCache().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerCache {
    return new ContainerCache().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerCache {
    return new ContainerCache().fromJsonString(jsonString, options);
  }

  static equals(a: ContainerCache | PlainMessage<ContainerCache> | undefined, b: ContainerCache | PlainMessage<ContainerCache> | undefined): boolean {
    return proto3.util.equals(ContainerCache, a, b);
  }
}

/**
 * A typed blob that can be attached to an instance.
 *
 * @generated from message namespace.cloud.compute.v1beta.Attachment
 */
export class Attachment extends Message<Attachment> {
  /**
   * @generated from field: string type_url = 1;
   */
  typeUrl = "";

  /**
   * @generated from field: bytes content = 2;
   */
  content = new Uint8Array(0);

  constructor(data?: PartialMessage<Attachment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.Attachment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "content", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Attachment {
    return new Attachment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Attachment {
    return new Attachment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Attachment {
    return new Attachment().fromJsonString(jsonString, options);
  }

  static equals(a: Attachment | PlainMessage<Attachment> | undefined, b: Attachment | PlainMessage<Attachment> | undefined): boolean {
    return proto3.util.equals(Attachment, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.StartContainersRequest
 */
export class StartContainersRequest extends Message<StartContainersRequest> {
  /**
   * The ID of instance which this call targets.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  /**
   * The set of additional containers that should be started in the target
   * instance.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.ContainerRequest containers = 2;
   */
  containers: ContainerRequest[] = [];

  constructor(data?: PartialMessage<StartContainersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.StartContainersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "containers", kind: "message", T: ContainerRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartContainersRequest {
    return new StartContainersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartContainersRequest {
    return new StartContainersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartContainersRequest {
    return new StartContainersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartContainersRequest | PlainMessage<StartContainersRequest> | undefined, b: StartContainersRequest | PlainMessage<StartContainersRequest> | undefined): boolean {
    return proto3.util.equals(StartContainersRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerRequest
 */
export class ContainerRequest extends Message<ContainerRequest> {
  /**
   * A name of the container being created. Must be unique.
   *
   * TODO: document valid regular expression.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * An image reference to the container image used to back this container.
   *
   * Ideally image references that are specified are fully resolved and
   * "pinned", i.e. their digest is also specified.
   *
   * If no resolved image is provided, it is resolved during creation time,
   * which may add latency to the creation request.
   *
   * Example:
   * `ubuntu:22.04@sha256:dfd64a3b4296d8c9b62aa3309984f8620b98d87e47492599ee20739e8eb54fbf`
   *
   * @generated from field: string image_ref = 2;
   */
  imageRef = "";

  /**
   * A set of arguments to pass to the container.
   *
   * TODO document relationship with entrypoint.
   *
   * Example: `["--foobar"]`
   *
   * @generated from field: repeated string args = 3;
   */
  args: string[] = [];

  /**
   * A set of environment values to be used as the container's environment.
   *
   * These set of environment variables are added in addition to a
   * system-specified set of environment variables.
   *
   * Example: `{"FOOBAR": "1"}`
   *
   * This API will always be supported, but you may want to consider
   * `env_vars` instead as a more complete API.
   *
   * @generated from field: map<string, string> environment = 4;
   */
  environment: { [key: string]: string } = {};

  /**
   * A set of environment values to be used as the container's environment.
   *
   * These set of environment variables are added in addition to a
   * system-specified set of environment variables.
   *
   * Example: `{"FOOBAR": "1"}`
   *
   * Can also refer to different source values, e.g. secrets.
   * By default, no secrets are injected.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.EnvironmentVariable env_vars = 14;
   */
  envVars: EnvironmentVariable[] = [];

  /**
   * If set, makes docker available to the container. Any containers that are
   * started by the container via the Docker API are then run as containers
   * alongside this container, not as children.
   *
   * Bind mounts work across containers by using container-aware bind mount
   * resolution.
   *
   * Example: `/var/run/docker.sock`
   *
   * @generated from field: string docker_sock_path = 5;
   */
  dockerSockPath = "";

  /**
   * If set, injects Namespace metadata and credentials to the container (e.g.
   * the workload token).
   *
   * Can be used to allow the container to call Namespace APIs as the
   * instance.
   *
   * Example: `/var/run/nsc`
   *
   * If set, mounts the nsc token (and state) in the container.
   *
   * @generated from field: string nsc_state_path = 6;
   */
  nscStatePath = "";

  /**
   * A set of container ports to make available through the public ingress.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.ContainerPort export_ports = 7;
   */
  exportPorts: ContainerPort[] = [];

  /**
   * By default containers run in a bridge network, with NAT. This allows
   * containers to listen on arbitrary ports without requiring coordination.
   *
   * The container can be run in the instance networking by specifying `HOST`.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerRequest.Network network = 9;
   */
  network = ContainerRequest_Network.NETWORK_UNKNOWN;

  /**
   * A list of experimental features to enable in this container.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures experimental = 10;
   */
  experimental?: ContainerRequest_ExperimentalFeatures;

  /**
   * Run the container with all capabilities.
   *
   * @generated from field: bool privileged = 11;
   */
  privileged = false;

  /**
   * A set of volumes to be attached to this container.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.VolumeRequest volumes = 12;
   */
  volumes: VolumeRequest[] = [];

  /**
   * When a container terminates, the instance where it runs in will also
   * terminate. If the workload type is set to `service`, the instance will always be
   * marked as failed, regardless of the exit code of the container.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerRequest.WorkloadType workload_type = 13;
   */
  workloadType = ContainerRequest_WorkloadType.WORKLOAD_TYPE_UNKNOWN;

  constructor(data?: PartialMessage<ContainerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "image_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "args", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "environment", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 14, name: "env_vars", kind: "message", T: EnvironmentVariable, repeated: true },
    { no: 5, name: "docker_sock_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "nsc_state_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "export_ports", kind: "message", T: ContainerPort, repeated: true },
    { no: 9, name: "network", kind: "enum", T: proto3.getEnumType(ContainerRequest_Network) },
    { no: 10, name: "experimental", kind: "message", T: ContainerRequest_ExperimentalFeatures },
    { no: 11, name: "privileged", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "volumes", kind: "message", T: VolumeRequest, repeated: true },
    { no: 13, name: "workload_type", kind: "enum", T: proto3.getEnumType(ContainerRequest_WorkloadType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerRequest {
    return new ContainerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerRequest {
    return new ContainerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerRequest {
    return new ContainerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ContainerRequest | PlainMessage<ContainerRequest> | undefined, b: ContainerRequest | PlainMessage<ContainerRequest> | undefined): boolean {
    return proto3.util.equals(ContainerRequest, a, b);
  }
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.ContainerRequest.Network
 */
export enum ContainerRequest_Network {
  /**
   * @generated from enum value: NETWORK_UNKNOWN = 0;
   */
  NETWORK_UNKNOWN = 0,

  /**
   * Default
   *
   * @generated from enum value: BRIDGE = 1;
   */
  BRIDGE = 1,

  /**
   * @generated from enum value: HOST = 2;
   */
  HOST = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ContainerRequest_Network)
proto3.util.setEnumType(ContainerRequest_Network, "namespace.cloud.compute.v1beta.ContainerRequest.Network", [
  { no: 0, name: "NETWORK_UNKNOWN" },
  { no: 1, name: "BRIDGE" },
  { no: 2, name: "HOST" },
]);

/**
 * @generated from enum namespace.cloud.compute.v1beta.ContainerRequest.WorkloadType
 */
export enum ContainerRequest_WorkloadType {
  /**
   * Defaults to JOB.
   *
   * @generated from enum value: WORKLOAD_TYPE_UNKNOWN = 0;
   */
  WORKLOAD_TYPE_UNKNOWN = 0,

  /**
   * Default; when a container terminates, the instance also terminates.
   *
   * @generated from enum value: JOB = 1;
   */
  JOB = 1,

  /**
   * The container is marked as critical, and if the container fails, the instance will fail with a fatal error.
   *
   * @generated from enum value: SERVICE = 2;
   */
  SERVICE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ContainerRequest_WorkloadType)
proto3.util.setEnumType(ContainerRequest_WorkloadType, "namespace.cloud.compute.v1beta.ContainerRequest.WorkloadType", [
  { no: 0, name: "WORKLOAD_TYPE_UNKNOWN" },
  { no: 1, name: "JOB" },
  { no: 2, name: "SERVICE" },
]);

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures
 */
export class ContainerRequest_ExperimentalFeatures extends Message<ContainerRequest_ExperimentalFeatures> {
  /**
   * Array of log file patterns to retain. Globbing is supported.
   *
   * @generated from field: repeated string include_logs = 1;
   */
  includeLogs: string[] = [];

  /**
   * A series of bind mounts to apply to the container. Can be used for
   * cross-container communication.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.HostMount host_mount = 2;
   */
  hostMount: ContainerRequest_ExperimentalFeatures_HostMount[] = [];

  /**
   * Run the container with all capabilities.
   * Deprecated: use privileged under the ContainerRequest.
   *
   * @generated from field: bool privileged = 3;
   */
  privileged = false;

  /**
   * Reach out to the Namespace team to learn more about this capability.
   *
   * @generated from field: map<string, string> exported_unix_sockets = 4;
   */
  exportedUnixSockets: { [key: string]: string } = {};

  /**
   * Additional credentials that can be used to pull the image used to back this container.
   *
   * Prefer using `CreateInstanceRequest.additional_registries` to provide persistent pull credentials for the instance.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.ImagePullCredentials image_pull_credentials = 5;
   */
  imagePullCredentials?: ContainerRequest_ExperimentalFeatures_ImagePullCredentials;

  /**
   * Store the contents of the run (and only the contents of the ephemeral
   * disk) as a new container image. Can only push to `nscr.io`.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.PushEphemeralDiskAsImage push_ephemeral_disk_as_image = 6;
   */
  pushEphemeralDiskAsImage?: ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage;

  /**
   * Set of capabilities to add to the container, e.g. NET_CAP.
   *
   * @generated from field: repeated string cap_add = 7;
   */
  capAdd: string[] = [];

  /**
   * Set of capabilities to drop.
   *
   * @generated from field: repeated string cap_drop = 8;
   */
  capDrop: string[] = [];

  /**
   * Set of devices to expose to the container.
   *
   * @generated from field: repeated string devices = 9;
   */
  devices: string[] = [];

  /**
   * A set of volumes that get mounted into arbitrary paths within the
   * container namespace. Always read only.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.SidecarVolume sidecar_volumes = 10;
   */
  sidecarVolumes: ContainerRequest_ExperimentalFeatures_SidecarVolume[] = [];

  /**
   * Chat with support@namespace.so about this setting.
   *
   * @generated from field: bool incremental_loading = 11;
   */
  incrementalLoading = false;

  /**
   * Chat with support@namespace.so about this setting.
   *
   * @generated from field: bool sandbox_like = 12;
   */
  sandboxLike = false;

  constructor(data?: PartialMessage<ContainerRequest_ExperimentalFeatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "include_logs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "host_mount", kind: "message", T: ContainerRequest_ExperimentalFeatures_HostMount, repeated: true },
    { no: 3, name: "privileged", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "exported_unix_sockets", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "image_pull_credentials", kind: "message", T: ContainerRequest_ExperimentalFeatures_ImagePullCredentials },
    { no: 6, name: "push_ephemeral_disk_as_image", kind: "message", T: ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage },
    { no: 7, name: "cap_add", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "cap_drop", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "devices", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "sidecar_volumes", kind: "message", T: ContainerRequest_ExperimentalFeatures_SidecarVolume, repeated: true },
    { no: 11, name: "incremental_loading", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "sandbox_like", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerRequest_ExperimentalFeatures {
    return new ContainerRequest_ExperimentalFeatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures {
    return new ContainerRequest_ExperimentalFeatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures {
    return new ContainerRequest_ExperimentalFeatures().fromJsonString(jsonString, options);
  }

  static equals(a: ContainerRequest_ExperimentalFeatures | PlainMessage<ContainerRequest_ExperimentalFeatures> | undefined, b: ContainerRequest_ExperimentalFeatures | PlainMessage<ContainerRequest_ExperimentalFeatures> | undefined): boolean {
    return proto3.util.equals(ContainerRequest_ExperimentalFeatures, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.HostMount
 */
export class ContainerRequest_ExperimentalFeatures_HostMount extends Message<ContainerRequest_ExperimentalFeatures_HostMount> {
  /**
   * @generated from field: string host_path = 1;
   */
  hostPath = "";

  /**
   * @generated from field: string container_path = 2;
   */
  containerPath = "";

  /**
   * @generated from field: bool readonly = 3;
   */
  readonly = false;

  constructor(data?: PartialMessage<ContainerRequest_ExperimentalFeatures_HostMount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.HostMount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "host_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "container_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "readonly", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerRequest_ExperimentalFeatures_HostMount {
    return new ContainerRequest_ExperimentalFeatures_HostMount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_HostMount {
    return new ContainerRequest_ExperimentalFeatures_HostMount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_HostMount {
    return new ContainerRequest_ExperimentalFeatures_HostMount().fromJsonString(jsonString, options);
  }

  static equals(a: ContainerRequest_ExperimentalFeatures_HostMount | PlainMessage<ContainerRequest_ExperimentalFeatures_HostMount> | undefined, b: ContainerRequest_ExperimentalFeatures_HostMount | PlainMessage<ContainerRequest_ExperimentalFeatures_HostMount> | undefined): boolean {
    return proto3.util.equals(ContainerRequest_ExperimentalFeatures_HostMount, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.ImagePullCredentials
 */
export class ContainerRequest_ExperimentalFeatures_ImagePullCredentials extends Message<ContainerRequest_ExperimentalFeatures_ImagePullCredentials> {
  /**
   * Namespace will federate with AWS to obtain an [ECR authorization token](https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_GetAuthorizationToken.html).
   * Make sure to grant the required `ecr:*` permissions to the federated IAM role.
   *
   * @generated from field: namespace.cloud.compute.v1beta.AWSCredentials aws_ecr = 1;
   */
  awsEcr?: AWSCredentials;

  constructor(data?: PartialMessage<ContainerRequest_ExperimentalFeatures_ImagePullCredentials>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.ImagePullCredentials";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aws_ecr", kind: "message", T: AWSCredentials },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerRequest_ExperimentalFeatures_ImagePullCredentials {
    return new ContainerRequest_ExperimentalFeatures_ImagePullCredentials().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_ImagePullCredentials {
    return new ContainerRequest_ExperimentalFeatures_ImagePullCredentials().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_ImagePullCredentials {
    return new ContainerRequest_ExperimentalFeatures_ImagePullCredentials().fromJsonString(jsonString, options);
  }

  static equals(a: ContainerRequest_ExperimentalFeatures_ImagePullCredentials | PlainMessage<ContainerRequest_ExperimentalFeatures_ImagePullCredentials> | undefined, b: ContainerRequest_ExperimentalFeatures_ImagePullCredentials | PlainMessage<ContainerRequest_ExperimentalFeatures_ImagePullCredentials> | undefined): boolean {
    return proto3.util.equals(ContainerRequest_ExperimentalFeatures_ImagePullCredentials, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.PushEphemeralDiskAsImage
 */
export class ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage extends Message<ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage> {
  /**
   * E.g. nscr.io/foobar/myimage
   *
   * @generated from field: string target_image_ref = 1;
   */
  targetImageRef = "";

  constructor(data?: PartialMessage<ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.PushEphemeralDiskAsImage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target_image_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage {
    return new ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage {
    return new ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage {
    return new ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage().fromJsonString(jsonString, options);
  }

  static equals(a: ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage | PlainMessage<ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage> | undefined, b: ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage | PlainMessage<ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage> | undefined): boolean {
    return proto3.util.equals(ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.SidecarVolume
 */
export class ContainerRequest_ExperimentalFeatures_SidecarVolume extends Message<ContainerRequest_ExperimentalFeatures_SidecarVolume> {
  /**
   * Optional.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string image_ref = 2;
   */
  imageRef = "";

  /**
   * @generated from field: string container_path = 3;
   */
  containerPath = "";

  constructor(data?: PartialMessage<ContainerRequest_ExperimentalFeatures_SidecarVolume>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.SidecarVolume";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "image_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "container_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerRequest_ExperimentalFeatures_SidecarVolume {
    return new ContainerRequest_ExperimentalFeatures_SidecarVolume().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_SidecarVolume {
    return new ContainerRequest_ExperimentalFeatures_SidecarVolume().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_SidecarVolume {
    return new ContainerRequest_ExperimentalFeatures_SidecarVolume().fromJsonString(jsonString, options);
  }

  static equals(a: ContainerRequest_ExperimentalFeatures_SidecarVolume | PlainMessage<ContainerRequest_ExperimentalFeatures_SidecarVolume> | undefined, b: ContainerRequest_ExperimentalFeatures_SidecarVolume | PlainMessage<ContainerRequest_ExperimentalFeatures_SidecarVolume> | undefined): boolean {
    return proto3.util.equals(ContainerRequest_ExperimentalFeatures_SidecarVolume, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.EnvironmentVariable
 */
export class EnvironmentVariable extends Message<EnvironmentVariable> {
  /**
   * Required: Name under which the environment variable will be available, e.g. "FOOBAR_VAR_NAME".
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Optional: If set, use this static value for the environment variable.
   *
   * @generated from field: string value = 2;
   */
  value = "";

  /**
   * Optional: If set, overrides value. Namespace will dynamically resolve the secret on instance creation.
   * By default, no secrets are resolved unless requested explicitly.
   *
   * @generated from field: string from_secret_id = 3;
   */
  fromSecretId = "";

  constructor(data?: PartialMessage<EnvironmentVariable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.EnvironmentVariable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "from_secret_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnvironmentVariable {
    return new EnvironmentVariable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnvironmentVariable {
    return new EnvironmentVariable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnvironmentVariable {
    return new EnvironmentVariable().fromJsonString(jsonString, options);
  }

  static equals(a: EnvironmentVariable | PlainMessage<EnvironmentVariable> | undefined, b: EnvironmentVariable | PlainMessage<EnvironmentVariable> | undefined): boolean {
    return proto3.util.equals(EnvironmentVariable, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AWSCredentials
 */
export class AWSCredentials extends Message<AWSCredentials> {
  /**
   * Amazon Resource Name of the IAM role to assume.
   * The IAM role must be [set up for federated access from Namespace](https://namespace.so/docs/federation/aws#accessing-aws-resources-from-namespace) including an appropriate trust policy.
   *
   * @generated from field: string assume_role_arn = 1;
   */
  assumeRoleArn = "";

  constructor(data?: PartialMessage<AWSCredentials>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AWSCredentials";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "assume_role_arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSCredentials {
    return new AWSCredentials().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSCredentials {
    return new AWSCredentials().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSCredentials {
    return new AWSCredentials().fromJsonString(jsonString, options);
  }

  static equals(a: AWSCredentials | PlainMessage<AWSCredentials> | undefined, b: AWSCredentials | PlainMessage<AWSCredentials> | undefined): boolean {
    return proto3.util.equals(AWSCredentials, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.StartContainersResponse
 */
export class StartContainersResponse extends Message<StartContainersResponse> {
  /**
   * The corresponding set of allocated containers. Containers are returned in
   * the same order they are requested.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.AllocatedContainer containers = 1;
   */
  containers: AllocatedContainer[] = [];

  constructor(data?: PartialMessage<StartContainersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.StartContainersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "containers", kind: "message", T: AllocatedContainer, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartContainersResponse {
    return new StartContainersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartContainersResponse {
    return new StartContainersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartContainersResponse {
    return new StartContainersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StartContainersResponse | PlainMessage<StartContainersResponse> | undefined, b: StartContainersResponse | PlainMessage<StartContainersResponse> | undefined): boolean {
    return proto3.util.equals(StartContainersResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ApplicationRequest
 */
export class ApplicationRequest extends Message<ApplicationRequest> {
  /**
   * A name of the application being created. Must be unique.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Optional image with application distribution to be mounted on the instance.
   *
   * Note that ENTRYPOINT/CMD specified in the image config are not respected.
   *
   * Example: `nscr.io/abc012abc012/foobar`
   *
   * @generated from field: string image_ref = 2;
   */
  imageRef = "";

  /**
   * Command to execute.
   *
   * May be:
   *
   * * Absolute (refers to a pre-installed binary in the base image).
   *   Example: `/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild`.
   *
   * * Relative to the image specified above.
   *   Example: `./postgres`.
   *
   * * Resolved from $PATH (using the default $PATH of the base image)
   *   Example: `xcrun`.
   *
   * @generated from field: string command = 14;
   */
  command = "";

  /**
   * A set of arguments to pass to the application.
   *
   * Example: `["--foobar"]`
   *
   * @generated from field: repeated string args = 3;
   */
  args: string[] = [];

  /**
   * A set of environment values to be used as the container's environment.
   *
   * These set of environment variables are added in addition to a
   * system-specified set of environment variables.
   *
   * Example: `{"FOOBAR": "1"}`
   * This API will always be supported, but you may want to consider
   * `env_vars` instead as a more complete API.
   *
   * @generated from field: map<string, string> environment = 4;
   */
  environment: { [key: string]: string } = {};

  /**
   * A set of environment values to be used as the container's environment.
   *
   * These set of environment variables are added in addition to a
   * system-specified set of environment variables.
   *
   * Example: `{"FOOBAR": "1"}`
   *
   * Can also refer to different source values, e.g. secrets.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.EnvironmentVariable env_vars = 15;
   */
  envVars: EnvironmentVariable[] = [];

  /**
   * When a container terminates, the instance where it runs in will also
   * terminate. If the workload type is set to `service`, the instance will always be
   * marked as failed, regardless of the exit code of the container.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ApplicationRequest.WorkloadType workload_type = 13;
   */
  workloadType = ApplicationRequest_WorkloadType.WORKLOAD_TYPE_UNKNOWN;

  /**
   * A list of experimental features to enable in this container.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ApplicationRequest.ExperimentalFeatures experimental = 10;
   */
  experimental?: ApplicationRequest_ExperimentalFeatures;

  constructor(data?: PartialMessage<ApplicationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ApplicationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "image_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "command", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "args", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "environment", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 15, name: "env_vars", kind: "message", T: EnvironmentVariable, repeated: true },
    { no: 13, name: "workload_type", kind: "enum", T: proto3.getEnumType(ApplicationRequest_WorkloadType) },
    { no: 10, name: "experimental", kind: "message", T: ApplicationRequest_ExperimentalFeatures },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApplicationRequest {
    return new ApplicationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApplicationRequest {
    return new ApplicationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApplicationRequest {
    return new ApplicationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ApplicationRequest | PlainMessage<ApplicationRequest> | undefined, b: ApplicationRequest | PlainMessage<ApplicationRequest> | undefined): boolean {
    return proto3.util.equals(ApplicationRequest, a, b);
  }
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.ApplicationRequest.WorkloadType
 */
export enum ApplicationRequest_WorkloadType {
  /**
   * Defaults to JOB.
   *
   * @generated from enum value: WORKLOAD_TYPE_UNKNOWN = 0;
   */
  WORKLOAD_TYPE_UNKNOWN = 0,

  /**
   * Default; when the application terminates, the instance also terminates.
   *
   * @generated from enum value: JOB = 1;
   */
  JOB = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ApplicationRequest_WorkloadType)
proto3.util.setEnumType(ApplicationRequest_WorkloadType, "namespace.cloud.compute.v1beta.ApplicationRequest.WorkloadType", [
  { no: 0, name: "WORKLOAD_TYPE_UNKNOWN" },
  { no: 1, name: "JOB" },
]);

/**
 * @generated from message namespace.cloud.compute.v1beta.ApplicationRequest.ExperimentalFeatures
 */
export class ApplicationRequest_ExperimentalFeatures extends Message<ApplicationRequest_ExperimentalFeatures> {
  /**
   * Array of log file patterns to retain. Globbing is supported.
   *
   * @generated from field: repeated string include_logs = 1;
   */
  includeLogs: string[] = [];

  constructor(data?: PartialMessage<ApplicationRequest_ExperimentalFeatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ApplicationRequest.ExperimentalFeatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "include_logs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApplicationRequest_ExperimentalFeatures {
    return new ApplicationRequest_ExperimentalFeatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApplicationRequest_ExperimentalFeatures {
    return new ApplicationRequest_ExperimentalFeatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApplicationRequest_ExperimentalFeatures {
    return new ApplicationRequest_ExperimentalFeatures().fromJsonString(jsonString, options);
  }

  static equals(a: ApplicationRequest_ExperimentalFeatures | PlainMessage<ApplicationRequest_ExperimentalFeatures> | undefined, b: ApplicationRequest_ExperimentalFeatures | PlainMessage<ApplicationRequest_ExperimentalFeatures> | undefined): boolean {
    return proto3.util.equals(ApplicationRequest_ExperimentalFeatures, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.DescribeInstanceRequest
 */
export class DescribeInstanceRequest extends Message<DescribeInstanceRequest> {
  /**
   * The ID of instance which this call targets.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  constructor(data?: PartialMessage<DescribeInstanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.DescribeInstanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeInstanceRequest {
    return new DescribeInstanceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeInstanceRequest {
    return new DescribeInstanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeInstanceRequest {
    return new DescribeInstanceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeInstanceRequest | PlainMessage<DescribeInstanceRequest> | undefined, b: DescribeInstanceRequest | PlainMessage<DescribeInstanceRequest> | undefined): boolean {
    return proto3.util.equals(DescribeInstanceRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.WaitInstanceRequest
 */
export class WaitInstanceRequest extends Message<WaitInstanceRequest> {
  /**
   * The ID of instance which this call targets.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  /**
   * If set to true, we don't fail the request if the instance is destroyed while waiting.
   *
   * @generated from field: bool destroyed_ok = 2;
   */
  destroyedOk = false;

  /**
   * The ID of the container to wait for.
   *
   * @generated from field: string container_id = 3;
   */
  containerId = "";

  constructor(data?: PartialMessage<WaitInstanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.WaitInstanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "destroyed_ok", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "container_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WaitInstanceRequest {
    return new WaitInstanceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WaitInstanceRequest {
    return new WaitInstanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WaitInstanceRequest {
    return new WaitInstanceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WaitInstanceRequest | PlainMessage<WaitInstanceRequest> | undefined, b: WaitInstanceRequest | PlainMessage<WaitInstanceRequest> | undefined): boolean {
    return proto3.util.equals(WaitInstanceRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.WaitInstanceResponse
 */
export class WaitInstanceResponse extends Message<WaitInstanceResponse> {
  /**
   * The up-to-date metadata of the specified instance.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata metadata = 1;
   */
  metadata?: InstanceMetadata;

  /**
   * If a container is specified, its status.
   *
   * @generated from field: string container_status = 2;
   */
  containerStatus = "";

  constructor(data?: PartialMessage<WaitInstanceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.WaitInstanceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: InstanceMetadata },
    { no: 2, name: "container_status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WaitInstanceResponse {
    return new WaitInstanceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WaitInstanceResponse {
    return new WaitInstanceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WaitInstanceResponse {
    return new WaitInstanceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WaitInstanceResponse | PlainMessage<WaitInstanceResponse> | undefined, b: WaitInstanceResponse | PlainMessage<WaitInstanceResponse> | undefined): boolean {
    return proto3.util.equals(WaitInstanceResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ExtendInstanceRequest
 */
export class ExtendInstanceRequest extends Message<ExtendInstanceRequest> {
  /**
   * The ID of the instance which should be extended.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  /**
   * The duration this instance should be extended by.
   *
   * Note: In JSON format, the Duration type is encoded as a string rather than an
   * object, where the string ends in the suffix "s" (indicating seconds) and
   * is preceded by the number of seconds, with nanoseconds expressed as
   * fractional seconds.
   *
   * @generated from field: google.protobuf.Duration extend_by = 2;
   */
  extendBy?: Duration;

  /**
   * The minimum duration this instance should be running.
   *
   * Note: In JSON format, the Duration type is encoded as a string rather than an
   * object, where the string ends in the suffix "s" (indicating seconds) and
   * is preceded by the number of seconds, with nanoseconds expressed as
   * fractional seconds.
   *
   * @generated from field: google.protobuf.Duration ensure_minimum = 3;
   */
  ensureMinimum?: Duration;

  /**
   * The new deadline (in UTC) at which the instance is destroyed.
   *
   * Note: In JSON format, the Timestamp type is encoded as a string in the
   * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
   *
   * @generated from field: google.protobuf.Timestamp new_deadline = 4;
   */
  newDeadline?: Timestamp;

  constructor(data?: PartialMessage<ExtendInstanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ExtendInstanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "extend_by", kind: "message", T: Duration },
    { no: 3, name: "ensure_minimum", kind: "message", T: Duration },
    { no: 4, name: "new_deadline", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtendInstanceRequest {
    return new ExtendInstanceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtendInstanceRequest {
    return new ExtendInstanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtendInstanceRequest {
    return new ExtendInstanceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExtendInstanceRequest | PlainMessage<ExtendInstanceRequest> | undefined, b: ExtendInstanceRequest | PlainMessage<ExtendInstanceRequest> | undefined): boolean {
    return proto3.util.equals(ExtendInstanceRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ExtendInstanceResponse
 */
export class ExtendInstanceResponse extends Message<ExtendInstanceResponse> {
  /**
   * The new deadline at which the instance is destroyed.
   *
   * @generated from field: google.protobuf.Timestamp new_deadline = 1;
   */
  newDeadline?: Timestamp;

  constructor(data?: PartialMessage<ExtendInstanceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ExtendInstanceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "new_deadline", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtendInstanceResponse {
    return new ExtendInstanceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtendInstanceResponse {
    return new ExtendInstanceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtendInstanceResponse {
    return new ExtendInstanceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExtendInstanceResponse | PlainMessage<ExtendInstanceResponse> | undefined, b: ExtendInstanceResponse | PlainMessage<ExtendInstanceResponse> | undefined): boolean {
    return proto3.util.equals(ExtendInstanceResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.DestroyInstanceRequest
 */
export class DestroyInstanceRequest extends Message<DestroyInstanceRequest> {
  /**
   * The ID of instance which this call targets.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  /**
   * The reason of destruction is persisted with the instance and can be
   * retrieved later.
   *
   * @generated from field: string reason = 2;
   */
  reason = "";

  constructor(data?: PartialMessage<DestroyInstanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.DestroyInstanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DestroyInstanceRequest {
    return new DestroyInstanceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DestroyInstanceRequest {
    return new DestroyInstanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DestroyInstanceRequest {
    return new DestroyInstanceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DestroyInstanceRequest | PlainMessage<DestroyInstanceRequest> | undefined, b: DestroyInstanceRequest | PlainMessage<DestroyInstanceRequest> | undefined): boolean {
    return proto3.util.equals(DestroyInstanceRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListInstancesRequest
 */
export class ListInstancesRequest extends Message<ListInstancesRequest> {
  /**
   * If a previous response returned a `pagination_cursor`, it can be
   * specified to continue reading results with the same arguments as the
   * original call.
   *
   * @generated from field: bytes pagination_cursor = 1;
   */
  paginationCursor = new Uint8Array(0);

  /**
   * The maximum number of entries to return as part of this ListInstances
   * request. A maximum number of entries may also be specified when
   * `pagination_cursor` is set.
   *
   * We won't return more than `max_entries`, but may return fewer.
   *
   * @generated from field: int64 max_entries = 2;
   */
  maxEntries = protoInt64.zero;

  /**
   * If not set, only returns instances in the PENDING, CREATING or RUNNING
   * states.
   *
   * If set, also includes instances in the DESTROYED and ERROR states.
   *
   * @generated from field: bool include_complete_runs = 3;
   */
  includeCompleteRuns = false;

  /**
   * Don't return instances that were created before the specified timestamp
   * (in UTC).
   *
   * Note: In JSON format, the Timestamp type is encoded as a string in the
   * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
   *
   * @generated from field: google.protobuf.Timestamp not_older_than = 4;
   */
  notOlderThan?: Timestamp;

  /**
   * Only return instances that match the specified filter.
   *
   * @generated from field: repeated namespace.stdlib.LabelFilterEntry label_filter = 5;
   */
  labelFilter: LabelFilterEntry[] = [];

  constructor(data?: PartialMessage<ListInstancesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListInstancesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pagination_cursor", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "max_entries", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "include_complete_runs", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "not_older_than", kind: "message", T: Timestamp },
    { no: 5, name: "label_filter", kind: "message", T: LabelFilterEntry, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInstancesRequest {
    return new ListInstancesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInstancesRequest {
    return new ListInstancesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInstancesRequest {
    return new ListInstancesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListInstancesRequest | PlainMessage<ListInstancesRequest> | undefined, b: ListInstancesRequest | PlainMessage<ListInstancesRequest> | undefined): boolean {
    return proto3.util.equals(ListInstancesRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListInstancesResponse
 */
export class ListInstancesResponse extends Message<ListInstancesResponse> {
  /**
   * The list of instances that match the filter.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.InstanceMetadata instances = 1;
   */
  instances: InstanceMetadata[] = [];

  /**
   * If set, there are additional results. Pass the same cursor to a
   * subsequent ListInstances call to continue fetching results.
   *
   * @generated from field: bytes pagination_cursor = 2;
   */
  paginationCursor = new Uint8Array(0);

  constructor(data?: PartialMessage<ListInstancesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListInstancesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instances", kind: "message", T: InstanceMetadata, repeated: true },
    { no: 2, name: "pagination_cursor", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInstancesResponse {
    return new ListInstancesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInstancesResponse {
    return new ListInstancesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInstancesResponse {
    return new ListInstancesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListInstancesResponse | PlainMessage<ListInstancesResponse> | undefined, b: ListInstancesResponse | PlainMessage<ListInstancesResponse> | undefined): boolean {
    return proto3.util.equals(ListInstancesResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerPort
 */
export class ContainerPort extends Message<ContainerPort> {
  /**
   * The protocol the port being expose uses. Must be set.
   *
   * If the protocol is set to `HTTP` then the platform exposes the port using
   * a HTTPS-terminating reverse proxy, which then communicates using http
   * (and not https) with the container.
   *
   * If the protocol is `TCP` then the platform exposes the port using TLS,
   * requiring a Namespace-issued certificate for authentication.
   *
   * Example: `HTTP`
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerPort.Proto proto = 1;
   */
  proto = ContainerPort_Proto.PROTO_UNKNOWN;

  /**
   * The port the container is listening on. For example, if exposing a HTTP
   * server, with `proto=HTTP`, the port the http server is listening on.
   *
   * Example: `3000`
   *
   * @generated from field: int32 container_port = 2;
   */
  containerPort = 0;

  /**
   * If a name is provided, it is used to generate the Internet-facing server
   * name used to access this port. If it's not provided, a random id is used.
   *
   * @generated from field: string name = 4;
   */
  name = "";

  /**
   * A set of rules that configure the ingress when accessing this exported
   * port. Only settable with `proto` is `HTTP`.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.HttpMatchRule http_match_rule = 3;
   */
  httpMatchRule: HttpMatchRule[] = [];

  constructor(data?: PartialMessage<ContainerPort>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerPort";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proto", kind: "enum", T: proto3.getEnumType(ContainerPort_Proto) },
    { no: 2, name: "container_port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "http_match_rule", kind: "message", T: HttpMatchRule, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerPort {
    return new ContainerPort().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerPort {
    return new ContainerPort().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerPort {
    return new ContainerPort().fromJsonString(jsonString, options);
  }

  static equals(a: ContainerPort | PlainMessage<ContainerPort> | undefined, b: ContainerPort | PlainMessage<ContainerPort> | undefined): boolean {
    return proto3.util.equals(ContainerPort, a, b);
  }
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.ContainerPort.Proto
 */
export enum ContainerPort_Proto {
  /**
   * @generated from enum value: PROTO_UNKNOWN = 0;
   */
  PROTO_UNKNOWN = 0,

  /**
   * @generated from enum value: HTTP = 1;
   */
  HTTP = 1,

  /**
   * @generated from enum value: TCP = 2;
   */
  TCP = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ContainerPort_Proto)
proto3.util.setEnumType(ContainerPort_Proto, "namespace.cloud.compute.v1beta.ContainerPort.Proto", [
  { no: 0, name: "PROTO_UNKNOWN" },
  { no: 1, name: "HTTP" },
  { no: 2, name: "TCP" },
]);

/**
 * @generated from message namespace.cloud.compute.v1beta.HttpMatchRule
 */
export class HttpMatchRule extends Message<HttpMatchRule> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.HttpMatchRule.HttpMatch match = 1;
   */
  match?: HttpMatchRule_HttpMatch;

  /**
   * @generated from field: bool does_not_require_auth = 2;
   */
  doesNotRequireAuth = false;

  constructor(data?: PartialMessage<HttpMatchRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.HttpMatchRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "match", kind: "message", T: HttpMatchRule_HttpMatch },
    { no: 2, name: "does_not_require_auth", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpMatchRule {
    return new HttpMatchRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpMatchRule {
    return new HttpMatchRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpMatchRule {
    return new HttpMatchRule().fromJsonString(jsonString, options);
  }

  static equals(a: HttpMatchRule | PlainMessage<HttpMatchRule> | undefined, b: HttpMatchRule | PlainMessage<HttpMatchRule> | undefined): boolean {
    return proto3.util.equals(HttpMatchRule, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.HttpMatchRule.HttpMatch
 */
export class HttpMatchRule_HttpMatch extends Message<HttpMatchRule_HttpMatch> {
  /**
   * If empty, matches any method.
   *
   * @generated from field: repeated string method = 1;
   */
  method: string[] = [];

  /**
   * If empty, matches any path.
   *
   * @generated from field: string path = 2;
   */
  path = "";

  constructor(data?: PartialMessage<HttpMatchRule_HttpMatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.HttpMatchRule.HttpMatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "method", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpMatchRule_HttpMatch {
    return new HttpMatchRule_HttpMatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpMatchRule_HttpMatch {
    return new HttpMatchRule_HttpMatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpMatchRule_HttpMatch {
    return new HttpMatchRule_HttpMatch().fromJsonString(jsonString, options);
  }

  static equals(a: HttpMatchRule_HttpMatch | PlainMessage<HttpMatchRule_HttpMatch> | undefined, b: HttpMatchRule_HttpMatch | PlainMessage<HttpMatchRule_HttpMatch> | undefined): boolean {
    return proto3.util.equals(HttpMatchRule_HttpMatch, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AllocatedContainer
 */
export class AllocatedContainer extends Message<AllocatedContainer> {
  /**
   * A Namespace-allocated ID for this container.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The user specified container name.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * The allocated exported ports, which include the allocated public ingress
   * URLs.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.AllocatedContainer.ExportedContainerPort exported_port = 3;
   */
  exportedPort: AllocatedContainer_ExportedContainerPort[] = [];

  constructor(data?: PartialMessage<AllocatedContainer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AllocatedContainer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "exported_port", kind: "message", T: AllocatedContainer_ExportedContainerPort, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllocatedContainer {
    return new AllocatedContainer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllocatedContainer {
    return new AllocatedContainer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllocatedContainer {
    return new AllocatedContainer().fromJsonString(jsonString, options);
  }

  static equals(a: AllocatedContainer | PlainMessage<AllocatedContainer> | undefined, b: AllocatedContainer | PlainMessage<AllocatedContainer> | undefined): boolean {
    return proto3.util.equals(AllocatedContainer, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AllocatedContainer.ExportedContainerPort
 */
export class AllocatedContainer_ExportedContainerPort extends Message<AllocatedContainer_ExportedContainerPort> {
  /**
   * The original specified protocol.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerPort.Proto proto = 1;
   */
  proto = ContainerPort_Proto.PROTO_UNKNOWN;

  /**
   * The original specified container port.
   *
   * @generated from field: int32 container_port = 2;
   */
  containerPort = 0;

  /**
   * The original specified http rules.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.HttpMatchRule http_match_rule = 3;
   */
  httpMatchRule: HttpMatchRule[] = [];

  /**
   * If required, the port exposed within the instance that translates to
   * the container port above. This port is available in host networking
   * only.
   *
   * @generated from field: int32 exported_port = 4;
   */
  exportedPort = 0;

  /**
   * The fully qualified domain that is configured in the public ingress
   * to map back to this exposed port. Check `endpoint` for the hostname
   * and port required to connect to the port.
   *
   * @generated from field: string fqdn = 5;
   */
  fqdn = "";

  /**
   * The endpoint to use to connect to the exported port. May include a
   * port number as well, e.g. "foo-xyz.ord.namespaced.app:444".
   *
   * @generated from field: string endpoint = 6;
   */
  endpoint = "";

  constructor(data?: PartialMessage<AllocatedContainer_ExportedContainerPort>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AllocatedContainer.ExportedContainerPort";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proto", kind: "enum", T: proto3.getEnumType(ContainerPort_Proto) },
    { no: 2, name: "container_port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "http_match_rule", kind: "message", T: HttpMatchRule, repeated: true },
    { no: 4, name: "exported_port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "fqdn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllocatedContainer_ExportedContainerPort {
    return new AllocatedContainer_ExportedContainerPort().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllocatedContainer_ExportedContainerPort {
    return new AllocatedContainer_ExportedContainerPort().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllocatedContainer_ExportedContainerPort {
    return new AllocatedContainer_ExportedContainerPort().fromJsonString(jsonString, options);
  }

  static equals(a: AllocatedContainer_ExportedContainerPort | PlainMessage<AllocatedContainer_ExportedContainerPort> | undefined, b: AllocatedContainer_ExportedContainerPort | PlainMessage<AllocatedContainer_ExportedContainerPort> | undefined): boolean {
    return proto3.util.equals(AllocatedContainer_ExportedContainerPort, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.SuspendInstanceRequest
 */
export class SuspendInstanceRequest extends Message<SuspendInstanceRequest> {
  /**
   * The ID of instance which this call targets.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  constructor(data?: PartialMessage<SuspendInstanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.SuspendInstanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SuspendInstanceRequest {
    return new SuspendInstanceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SuspendInstanceRequest {
    return new SuspendInstanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SuspendInstanceRequest {
    return new SuspendInstanceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SuspendInstanceRequest | PlainMessage<SuspendInstanceRequest> | undefined, b: SuspendInstanceRequest | PlainMessage<SuspendInstanceRequest> | undefined): boolean {
    return proto3.util.equals(SuspendInstanceRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.WakeInstanceRequest
 */
export class WakeInstanceRequest extends Message<WakeInstanceRequest> {
  /**
   * The ID of instance which this call targets.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  constructor(data?: PartialMessage<WakeInstanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.WakeInstanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WakeInstanceRequest {
    return new WakeInstanceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WakeInstanceRequest {
    return new WakeInstanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WakeInstanceRequest {
    return new WakeInstanceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WakeInstanceRequest | PlainMessage<WakeInstanceRequest> | undefined, b: WakeInstanceRequest | PlainMessage<WakeInstanceRequest> | undefined): boolean {
    return proto3.util.equals(WakeInstanceRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceExtendedMetadata
 */
export class InstanceExtendedMetadata extends Message<InstanceExtendedMetadata> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.InstanceExtendedMetadata.SshMetadata ssh_metadata = 1;
   */
  sshMetadata?: InstanceExtendedMetadata_SshMetadata;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.InstanceExtendedMetadata.KubernetesInstanceMetadata kubernetes_metadata = 2;
   */
  kubernetesMetadata?: InstanceExtendedMetadata_KubernetesInstanceMetadata;

  /**
   * @generated from field: repeated namespace.cloud.compute.v1beta.InstanceExtendedMetadata.AllocatedTlsBackedPort tls_backed_port = 3;
   */
  tlsBackedPort: InstanceExtendedMetadata_AllocatedTlsBackedPort[] = [];

  /**
   * @generated from field: string command_service_endpoint = 4;
   */
  commandServiceEndpoint = "";

  constructor(data?: PartialMessage<InstanceExtendedMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceExtendedMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ssh_metadata", kind: "message", T: InstanceExtendedMetadata_SshMetadata },
    { no: 2, name: "kubernetes_metadata", kind: "message", T: InstanceExtendedMetadata_KubernetesInstanceMetadata },
    { no: 3, name: "tls_backed_port", kind: "message", T: InstanceExtendedMetadata_AllocatedTlsBackedPort, repeated: true },
    { no: 4, name: "command_service_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceExtendedMetadata {
    return new InstanceExtendedMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata {
    return new InstanceExtendedMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata {
    return new InstanceExtendedMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceExtendedMetadata | PlainMessage<InstanceExtendedMetadata> | undefined, b: InstanceExtendedMetadata | PlainMessage<InstanceExtendedMetadata> | undefined): boolean {
    return proto3.util.equals(InstanceExtendedMetadata, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceExtendedMetadata.SshMetadata
 */
export class InstanceExtendedMetadata_SshMetadata extends Message<InstanceExtendedMetadata_SshMetadata> {
  /**
   * @generated from field: string ssh_proxy_endpoint = 1;
   */
  sshProxyEndpoint = "";

  /**
   * @generated from field: bytes ssh_private_key = 2;
   */
  sshPrivateKey = new Uint8Array(0);

  constructor(data?: PartialMessage<InstanceExtendedMetadata_SshMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceExtendedMetadata.SshMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ssh_proxy_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ssh_private_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceExtendedMetadata_SshMetadata {
    return new InstanceExtendedMetadata_SshMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata_SshMetadata {
    return new InstanceExtendedMetadata_SshMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata_SshMetadata {
    return new InstanceExtendedMetadata_SshMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceExtendedMetadata_SshMetadata | PlainMessage<InstanceExtendedMetadata_SshMetadata> | undefined, b: InstanceExtendedMetadata_SshMetadata | PlainMessage<InstanceExtendedMetadata_SshMetadata> | undefined): boolean {
    return proto3.util.equals(InstanceExtendedMetadata_SshMetadata, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceExtendedMetadata.KubernetesInstanceMetadata
 */
export class InstanceExtendedMetadata_KubernetesInstanceMetadata extends Message<InstanceExtendedMetadata_KubernetesInstanceMetadata> {
  /**
   * @generated from field: string endpoint_address = 1;
   */
  endpointAddress = "";

  /**
   * @generated from field: bytes certificate_authority_data = 2;
   */
  certificateAuthorityData = new Uint8Array(0);

  /**
   * @generated from field: bytes client_certificate_data = 3;
   */
  clientCertificateData = new Uint8Array(0);

  /**
   * @generated from field: bytes client_key_data = 4;
   */
  clientKeyData = new Uint8Array(0);

  /**
   * @generated from field: string kubernetes_distribution = 5;
   */
  kubernetesDistribution = "";

  constructor(data?: PartialMessage<InstanceExtendedMetadata_KubernetesInstanceMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceExtendedMetadata.KubernetesInstanceMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "endpoint_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "certificate_authority_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "client_certificate_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "client_key_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "kubernetes_distribution", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceExtendedMetadata_KubernetesInstanceMetadata {
    return new InstanceExtendedMetadata_KubernetesInstanceMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata_KubernetesInstanceMetadata {
    return new InstanceExtendedMetadata_KubernetesInstanceMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata_KubernetesInstanceMetadata {
    return new InstanceExtendedMetadata_KubernetesInstanceMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceExtendedMetadata_KubernetesInstanceMetadata | PlainMessage<InstanceExtendedMetadata_KubernetesInstanceMetadata> | undefined, b: InstanceExtendedMetadata_KubernetesInstanceMetadata | PlainMessage<InstanceExtendedMetadata_KubernetesInstanceMetadata> | undefined): boolean {
    return proto3.util.equals(InstanceExtendedMetadata_KubernetesInstanceMetadata, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceExtendedMetadata.AllocatedTlsBackedPort
 */
export class InstanceExtendedMetadata_AllocatedTlsBackedPort extends Message<InstanceExtendedMetadata_AllocatedTlsBackedPort> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: int32 port = 2;
   */
  port = 0;

  /**
   * @generated from field: string server_name = 3;
   */
  serverName = "";

  constructor(data?: PartialMessage<InstanceExtendedMetadata_AllocatedTlsBackedPort>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceExtendedMetadata.AllocatedTlsBackedPort";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "server_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceExtendedMetadata_AllocatedTlsBackedPort {
    return new InstanceExtendedMetadata_AllocatedTlsBackedPort().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata_AllocatedTlsBackedPort {
    return new InstanceExtendedMetadata_AllocatedTlsBackedPort().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata_AllocatedTlsBackedPort {
    return new InstanceExtendedMetadata_AllocatedTlsBackedPort().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceExtendedMetadata_AllocatedTlsBackedPort | PlainMessage<InstanceExtendedMetadata_AllocatedTlsBackedPort> | undefined, b: InstanceExtendedMetadata_AllocatedTlsBackedPort | PlainMessage<InstanceExtendedMetadata_AllocatedTlsBackedPort> | undefined): boolean {
    return proto3.util.equals(InstanceExtendedMetadata_AllocatedTlsBackedPort, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceMetadata
 */
export class InstanceMetadata extends Message<InstanceMetadata> {
  /**
   * The ID of the instance created.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  /**
   * The timestamp of when the instance was created (in UTC).
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * The timestamp of when the instance was destroyed (in UTC). Not set if the
   * instance is one of PENDING, CREATING or RUNNING states.
   *
   * @generated from field: google.protobuf.Timestamp destroyed_at = 3;
   */
  destroyedAt?: Timestamp;

  /**
   * The computed deadline of the instance (in UTC). The instance will be
   * garbage collected when it his its deadline.
   *
   * @generated from field: google.protobuf.Timestamp deadline = 4;
   */
  deadline?: Timestamp;

  /**
   * The user specified documented purpose.
   *
   * @generated from field: string documented_purpose = 5;
   */
  documentedPurpose = "";

  /**
   * The user specified instance shape (cpu, memory, disk).
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceShape shape = 6;
   */
  shape?: InstanceShape;

  /**
   * The status the instance is in.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata.Status status = 7;
   */
  status = InstanceMetadata_Status.STATUS_UNKNOWN;

  /**
   * The region-specific base ingress domain used to back created ingresses.
   *
   * Example: `fra1.nscluster.cloud`.
   *
   * @generated from field: string ingress_domain = 8;
   */
  ingressDomain = "";

  /**
   * The user specified instance labels.
   *
   * @generated from field: repeated namespace.stdlib.Label labels = 9;
   */
  labels: Label[] = [];

  /**
   * If the used authorization token has a `creator_id`, it is retained for
   * debugging purposes.
   *
   * @generated from field: string creator_id = 10;
   */
  creatorId = "";

  /**
   * Maintain state of each of the exported system services in this instance.
   * Examples of system services are `buildkit`, `kubernetes`, etc.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.InstanceMetadata.Service services = 11;
   */
  services: InstanceMetadata_Service[] = [];

  /**
   * Information related to where the instance is running, or ran, including
   * geography, and hw platform.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata.HWDeployment hw_deployment = 12;
   */
  hwDeployment?: InstanceMetadata_HWDeployment;

  constructor(data?: PartialMessage<InstanceMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "destroyed_at", kind: "message", T: Timestamp },
    { no: 4, name: "deadline", kind: "message", T: Timestamp },
    { no: 5, name: "documented_purpose", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "shape", kind: "message", T: InstanceShape },
    { no: 7, name: "status", kind: "enum", T: proto3.getEnumType(InstanceMetadata_Status) },
    { no: 8, name: "ingress_domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "labels", kind: "message", T: Label, repeated: true },
    { no: 10, name: "creator_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "services", kind: "message", T: InstanceMetadata_Service, repeated: true },
    { no: 12, name: "hw_deployment", kind: "message", T: InstanceMetadata_HWDeployment },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceMetadata {
    return new InstanceMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceMetadata {
    return new InstanceMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceMetadata {
    return new InstanceMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceMetadata | PlainMessage<InstanceMetadata> | undefined, b: InstanceMetadata | PlainMessage<InstanceMetadata> | undefined): boolean {
    return proto3.util.equals(InstanceMetadata, a, b);
  }
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.InstanceMetadata.Status
 */
export enum InstanceMetadata_Status {
  /**
   * @generated from enum value: STATUS_UNKNOWN = 0;
   */
  STATUS_UNKNOWN = 0,

  /**
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * @generated from enum value: CREATING = 2;
   */
  CREATING = 2,

  /**
   * @generated from enum value: RUNNING = 3;
   */
  RUNNING = 3,

  /**
   * @generated from enum value: DESTROYED = 4;
   */
  DESTROYED = 4,

  /**
   * @generated from enum value: DESTROYING = 5;
   */
  DESTROYING = 5,

  /**
   * @generated from enum value: SUSPENDING = 6;
   */
  SUSPENDING = 6,

  /**
   * @generated from enum value: SUSPENDED = 7;
   */
  SUSPENDED = 7,

  /**
   * @generated from enum value: ERROR = 8;
   */
  ERROR = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(InstanceMetadata_Status)
proto3.util.setEnumType(InstanceMetadata_Status, "namespace.cloud.compute.v1beta.InstanceMetadata.Status", [
  { no: 0, name: "STATUS_UNKNOWN" },
  { no: 1, name: "PENDING" },
  { no: 2, name: "CREATING" },
  { no: 3, name: "RUNNING" },
  { no: 4, name: "DESTROYED" },
  { no: 5, name: "DESTROYING" },
  { no: 6, name: "SUSPENDING" },
  { no: 7, name: "SUSPENDED" },
  { no: 8, name: "ERROR" },
]);

/**
 * A service represents an internal service that is proxiable when an
 * authenticated request is performed that proves that the caller has access
 * to the instance.
 *
 * Access to services does not follow the gRPC service model, and goes over
 * Namespace's programmable ingress directly, being a mix of either
 * WebSocket- or HTTP-backed implementations.
 *
 * @generated from message namespace.cloud.compute.v1beta.InstanceMetadata.Service
 */
export class InstanceMetadata_Service extends Message<InstanceMetadata_Service> {
  /**
   * The name of the service, e.g. "ssh", "docker" or "containerd".
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * It's current status, one of PENDING or READY.
   *
   * Note: It's not guaranteed that all services emit a PENDING state
   * before becoming READY. The fact that they're starting can sometimes
   * result in a lack of a ServiceState entry for that service.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata.Service.Status status = 2;
   */
  status = InstanceMetadata_Service_Status.STATUS_UNKNOWN;

  /**
   * Identifies what application transport this endpoint implements.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata.Service.EndpointKind endpoint_kind = 3;
   */
  endpointKind = InstanceMetadata_Service_EndpointKind.ENDPOINT_KIND_UNKNOWN;

  /**
   * The application-specific endpoint. Typically a URL.
   *
   * Example: `wss://gate.fra1.nscluster.cloud/ui3e3e3g7cfrg/22`
   *
   * @generated from field: string endpoint = 4;
   */
  endpoint = "";

  constructor(data?: PartialMessage<InstanceMetadata_Service>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceMetadata.Service";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(InstanceMetadata_Service_Status) },
    { no: 3, name: "endpoint_kind", kind: "enum", T: proto3.getEnumType(InstanceMetadata_Service_EndpointKind) },
    { no: 4, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceMetadata_Service {
    return new InstanceMetadata_Service().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceMetadata_Service {
    return new InstanceMetadata_Service().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceMetadata_Service {
    return new InstanceMetadata_Service().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceMetadata_Service | PlainMessage<InstanceMetadata_Service> | undefined, b: InstanceMetadata_Service | PlainMessage<InstanceMetadata_Service> | undefined): boolean {
    return proto3.util.equals(InstanceMetadata_Service, a, b);
  }
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.InstanceMetadata.Service.Status
 */
export enum InstanceMetadata_Service_Status {
  /**
   * @generated from enum value: STATUS_UNKNOWN = 0;
   */
  STATUS_UNKNOWN = 0,

  /**
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * @generated from enum value: READY = 2;
   */
  READY = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(InstanceMetadata_Service_Status)
proto3.util.setEnumType(InstanceMetadata_Service_Status, "namespace.cloud.compute.v1beta.InstanceMetadata.Service.Status", [
  { no: 0, name: "STATUS_UNKNOWN" },
  { no: 1, name: "PENDING" },
  { no: 2, name: "READY" },
]);

/**
 * @generated from enum namespace.cloud.compute.v1beta.InstanceMetadata.Service.EndpointKind
 */
export enum InstanceMetadata_Service_EndpointKind {
  /**
   * @generated from enum value: ENDPOINT_KIND_UNKNOWN = 0;
   */
  ENDPOINT_KIND_UNKNOWN = 0,

  /**
   * The service is a regular HTTP 1.1/2 service with a TLS frontend.
   *
   * Authentication is provided using a Bearer token passed to the
   * ingress on a `x-nsc-ingress-auth` header.
   *
   * @generated from enum value: HTTPS = 1;
   */
  HTTPS = 1,

  /**
   * The service proxies an API which maps back to an
   * application-specific transport, with messages following an
   * application-specific framing and transmitted over a secure
   * WebSocket, using BinaryMessage.
   *
   * For example, when accessing the docker service, the websocket
   * serves the same stream as one would get if connecting locally to
   * the dockerd socket over Unix Sockets.
   *
   * Authentication is provided using a Bearer token passed to the
   * ingress on either:
   * - Via a `x-nsc-ingress-auth` header, with a `Bearer` prefix, e.g.
   *   `Bearer nsct_abc...`.
   * - By specifying a query argument `x-nsc-ingress-auth` where the
   *   value is the token itself, e.g. `?x-nsc-ingress-auth=abc...`.
   *
   * @generated from enum value: PROXY_OVER_SECURE_WEBSOCKET = 2;
   */
  PROXY_OVER_SECURE_WEBSOCKET = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(InstanceMetadata_Service_EndpointKind)
proto3.util.setEnumType(InstanceMetadata_Service_EndpointKind, "namespace.cloud.compute.v1beta.InstanceMetadata.Service.EndpointKind", [
  { no: 0, name: "ENDPOINT_KIND_UNKNOWN" },
  { no: 1, name: "HTTPS" },
  { no: 2, name: "PROXY_OVER_SECURE_WEBSOCKET" },
]);

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceMetadata.ShutdownReason
 */
export class InstanceMetadata_ShutdownReason extends Message<InstanceMetadata_ShutdownReason> {
  /**
   * @generated from field: int32 error_code = 1;
   */
  errorCode = 0;

  /**
   * @generated from field: string error_message = 2;
   */
  errorMessage = "";

  /**
   * @generated from field: string container_nsc_id = 3;
   */
  containerNscId = "";

  /**
   * @generated from field: string container_name = 4;
   */
  containerName = "";

  /**
   * @generated from field: string container_failed_reason = 5;
   */
  containerFailedReason = "";

  constructor(data?: PartialMessage<InstanceMetadata_ShutdownReason>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceMetadata.ShutdownReason";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error_code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "container_nsc_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "container_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "container_failed_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceMetadata_ShutdownReason {
    return new InstanceMetadata_ShutdownReason().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceMetadata_ShutdownReason {
    return new InstanceMetadata_ShutdownReason().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceMetadata_ShutdownReason {
    return new InstanceMetadata_ShutdownReason().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceMetadata_ShutdownReason | PlainMessage<InstanceMetadata_ShutdownReason> | undefined, b: InstanceMetadata_ShutdownReason | PlainMessage<InstanceMetadata_ShutdownReason> | undefined): boolean {
    return proto3.util.equals(InstanceMetadata_ShutdownReason, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceMetadata.HWDeployment
 */
export class InstanceMetadata_HWDeployment extends Message<InstanceMetadata_HWDeployment> {
  /**
   * In which continent was the instance deployed to, one of "us" or "eu".
   *
   * @generated from field: string geo_continent = 1;
   */
  geoContinent = "";

  /**
   * What hardware platform was the instance deployed to, one of "a1", "a2", "mac-m2" or "arm2".
   *
   * @generated from field: string major_hwplatform = 2;
   */
  majorHwplatform = "";

  constructor(data?: PartialMessage<InstanceMetadata_HWDeployment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceMetadata.HWDeployment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "geo_continent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "major_hwplatform", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceMetadata_HWDeployment {
    return new InstanceMetadata_HWDeployment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceMetadata_HWDeployment {
    return new InstanceMetadata_HWDeployment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceMetadata_HWDeployment {
    return new InstanceMetadata_HWDeployment().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceMetadata_HWDeployment | PlainMessage<InstanceMetadata_HWDeployment> | undefined, b: InstanceMetadata_HWDeployment | PlainMessage<InstanceMetadata_HWDeployment> | undefined): boolean {
    return proto3.util.equals(InstanceMetadata_HWDeployment, a, b);
  }
}

/**
 * Defines an instance shape: the combination of CPU, RAM and Disk that the
 * instance should use.
 *
 * Usable values are constrained by policy, and are typically only settable in
 * values as powers of two.
 *
 * @generated from message namespace.cloud.compute.v1beta.InstanceShape
 */
export class InstanceShape extends Message<InstanceShape> {
  /**
   * @generated from field: int32 virtual_cpu = 1;
   */
  virtualCpu = 0;

  /**
   * @generated from field: int32 memory_megabytes = 2;
   */
  memoryMegabytes = 0;

  /**
   * Architecture of the instance, e.g. "amd64" or "arm64".
   *
   * @generated from field: string machine_arch = 3;
   */
  machineArch = "";

  /**
   * Operating system of the instance, e.g. "linux" or "macos".
   *
   * @generated from field: string os = 4;
   */
  os = "";

  /**
   * Provide additional constraints to instance selection. Available selectors:
   * https://namespace.so/docs/architecture/compute/macos#available-selectors
   *
   * @generated from field: repeated namespace.stdlib.Label selectors = 5;
   */
  selectors: Label[] = [];

  constructor(data?: PartialMessage<InstanceShape>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceShape";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "virtual_cpu", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "memory_megabytes", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "machine_arch", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "os", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "selectors", kind: "message", T: Label, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceShape {
    return new InstanceShape().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceShape {
    return new InstanceShape().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceShape {
    return new InstanceShape().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceShape | PlainMessage<InstanceShape> | undefined, b: InstanceShape | PlainMessage<InstanceShape> | undefined): boolean {
    return proto3.util.equals(InstanceShape, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ImageRegistry
 */
export class ImageRegistry extends Message<ImageRegistry> {
  /**
   * @generated from field: string endpoint_address = 1;
   */
  endpointAddress = "";

  /**
   * @generated from field: string repository = 2;
   */
  repository = "";

  constructor(data?: PartialMessage<ImageRegistry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ImageRegistry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "endpoint_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "repository", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageRegistry {
    return new ImageRegistry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageRegistry {
    return new ImageRegistry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageRegistry {
    return new ImageRegistry().fromJsonString(jsonString, options);
  }

  static equals(a: ImageRegistry | PlainMessage<ImageRegistry> | undefined, b: ImageRegistry | PlainMessage<ImageRegistry> | undefined): boolean {
    return proto3.util.equals(ImageRegistry, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateIngressRequest
 */
export class CreateIngressRequest extends Message<CreateIngressRequest> {
  /**
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  /**
   * @generated from field: repeated namespace.cloud.compute.v1beta.IngressRequest ingresses = 2;
   */
  ingresses: IngressRequest[] = [];

  constructor(data?: PartialMessage<CreateIngressRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateIngressRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ingresses", kind: "message", T: IngressRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateIngressRequest {
    return new CreateIngressRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateIngressRequest {
    return new CreateIngressRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateIngressRequest {
    return new CreateIngressRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateIngressRequest | PlainMessage<CreateIngressRequest> | undefined, b: CreateIngressRequest | PlainMessage<CreateIngressRequest> | undefined): boolean {
    return proto3.util.equals(CreateIngressRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.IngressRequest
 */
export class IngressRequest extends Message<IngressRequest> {
  /**
   * A name is an string that matches the regular expression `[a-z0-9]([a-z0-9-_]*[a-z0-9])?`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: repeated namespace.cloud.compute.v1beta.HttpMatchRule http_match_rule = 2;
   */
  httpMatchRule: HttpMatchRule[] = [];

  /**
   * @generated from field: namespace.cloud.compute.v1beta.ExportedPortBackend exported_port_backend = 3;
   */
  exportedPortBackend?: ExportedPortBackend;

  /**
   * Routes all first-level sub domains of the instance wildcard domain to this ingress.
   * Requires the hosting instance to have a wildcard domain (enabled via CreateInstanceRequest.experimental.enable_wildcard_domain).
   *
   * @generated from field: bool wildcard = 4;
   */
  wildcard = false;

  constructor(data?: PartialMessage<IngressRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.IngressRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "http_match_rule", kind: "message", T: HttpMatchRule, repeated: true },
    { no: 3, name: "exported_port_backend", kind: "message", T: ExportedPortBackend },
    { no: 4, name: "wildcard", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IngressRequest {
    return new IngressRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IngressRequest {
    return new IngressRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IngressRequest {
    return new IngressRequest().fromJsonString(jsonString, options);
  }

  static equals(a: IngressRequest | PlainMessage<IngressRequest> | undefined, b: IngressRequest | PlainMessage<IngressRequest> | undefined): boolean {
    return proto3.util.equals(IngressRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateIngressResponse
 */
export class CreateIngressResponse extends Message<CreateIngressResponse> {
  /**
   * @generated from field: repeated namespace.cloud.compute.v1beta.AllocatedIngress allocated_ingresses = 1;
   */
  allocatedIngresses: AllocatedIngress[] = [];

  constructor(data?: PartialMessage<CreateIngressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateIngressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allocated_ingresses", kind: "message", T: AllocatedIngress, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateIngressResponse {
    return new CreateIngressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateIngressResponse {
    return new CreateIngressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateIngressResponse {
    return new CreateIngressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateIngressResponse | PlainMessage<CreateIngressResponse> | undefined, b: CreateIngressResponse | PlainMessage<CreateIngressResponse> | undefined): boolean {
    return proto3.util.equals(CreateIngressResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListIngressesRequest
 */
export class ListIngressesRequest extends Message<ListIngressesRequest> {
  /**
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  constructor(data?: PartialMessage<ListIngressesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListIngressesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIngressesRequest {
    return new ListIngressesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIngressesRequest {
    return new ListIngressesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIngressesRequest {
    return new ListIngressesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListIngressesRequest | PlainMessage<ListIngressesRequest> | undefined, b: ListIngressesRequest | PlainMessage<ListIngressesRequest> | undefined): boolean {
    return proto3.util.equals(ListIngressesRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListIngressesResponse
 */
export class ListIngressesResponse extends Message<ListIngressesResponse> {
  /**
   * @generated from field: repeated namespace.cloud.compute.v1beta.AllocatedIngress allocated_ingresses = 1;
   */
  allocatedIngresses: AllocatedIngress[] = [];

  constructor(data?: PartialMessage<ListIngressesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListIngressesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allocated_ingresses", kind: "message", T: AllocatedIngress, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIngressesResponse {
    return new ListIngressesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIngressesResponse {
    return new ListIngressesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIngressesResponse {
    return new ListIngressesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListIngressesResponse | PlainMessage<ListIngressesResponse> | undefined, b: ListIngressesResponse | PlainMessage<ListIngressesResponse> | undefined): boolean {
    return proto3.util.equals(ListIngressesResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AllocatedIngress
 */
export class AllocatedIngress extends Message<AllocatedIngress> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string fqdn = 2;
   */
  fqdn = "";

  /**
   * @generated from field: string description = 3;
   */
  description = "";

  constructor(data?: PartialMessage<AllocatedIngress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AllocatedIngress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "fqdn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllocatedIngress {
    return new AllocatedIngress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllocatedIngress {
    return new AllocatedIngress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllocatedIngress {
    return new AllocatedIngress().fromJsonString(jsonString, options);
  }

  static equals(a: AllocatedIngress | PlainMessage<AllocatedIngress> | undefined, b: AllocatedIngress | PlainMessage<AllocatedIngress> | undefined): boolean {
    return proto3.util.equals(AllocatedIngress, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ExportedPortBackend
 */
export class ExportedPortBackend extends Message<ExportedPortBackend> {
  /**
   * @generated from field: int32 port = 1;
   */
  port = 0;

  constructor(data?: PartialMessage<ExportedPortBackend>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ExportedPortBackend";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportedPortBackend {
    return new ExportedPortBackend().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportedPortBackend {
    return new ExportedPortBackend().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportedPortBackend {
    return new ExportedPortBackend().fromJsonString(jsonString, options);
  }

  static equals(a: ExportedPortBackend | PlainMessage<ExportedPortBackend> | undefined, b: ExportedPortBackend | PlainMessage<ExportedPortBackend> | undefined): boolean {
    return proto3.util.equals(ExportedPortBackend, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetKubernetesConfigRequest
 */
export class GetKubernetesConfigRequest extends Message<GetKubernetesConfigRequest> {
  /**
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  constructor(data?: PartialMessage<GetKubernetesConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetKubernetesConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKubernetesConfigRequest {
    return new GetKubernetesConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKubernetesConfigRequest {
    return new GetKubernetesConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKubernetesConfigRequest {
    return new GetKubernetesConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetKubernetesConfigRequest | PlainMessage<GetKubernetesConfigRequest> | undefined, b: GetKubernetesConfigRequest | PlainMessage<GetKubernetesConfigRequest> | undefined): boolean {
    return proto3.util.equals(GetKubernetesConfigRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetKubernetesConfigResponse
 */
export class GetKubernetesConfigResponse extends Message<GetKubernetesConfigResponse> {
  /**
   * @generated from field: string kubeconfig = 1;
   */
  kubeconfig = "";

  constructor(data?: PartialMessage<GetKubernetesConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetKubernetesConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kubeconfig", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKubernetesConfigResponse {
    return new GetKubernetesConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKubernetesConfigResponse {
    return new GetKubernetesConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKubernetesConfigResponse {
    return new GetKubernetesConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetKubernetesConfigResponse | PlainMessage<GetKubernetesConfigResponse> | undefined, b: GetKubernetesConfigResponse | PlainMessage<GetKubernetesConfigResponse> | undefined): boolean {
    return proto3.util.equals(GetKubernetesConfigResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.VolumeRequest
 */
export class VolumeRequest extends Message<VolumeRequest> {
  /**
   * @generated from field: string mount_point = 1;
   */
  mountPoint = "";

  /**
   * @generated from field: string tag = 2;
   */
  tag = "";

  /**
   * @generated from field: int64 size_mb = 3;
   */
  sizeMb = protoInt64.zero;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.VolumeRequest.PersistencyKind persistency_kind = 4;
   */
  persistencyKind = VolumeRequest_PersistencyKind.PERSISTENCY_UNKNOWN;

  constructor(data?: PartialMessage<VolumeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.VolumeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mount_point", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "size_mb", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "persistency_kind", kind: "enum", T: proto3.getEnumType(VolumeRequest_PersistencyKind) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VolumeRequest {
    return new VolumeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VolumeRequest {
    return new VolumeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VolumeRequest {
    return new VolumeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: VolumeRequest | PlainMessage<VolumeRequest> | undefined, b: VolumeRequest | PlainMessage<VolumeRequest> | undefined): boolean {
    return proto3.util.equals(VolumeRequest, a, b);
  }
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.VolumeRequest.PersistencyKind
 */
export enum VolumeRequest_PersistencyKind {
  /**
   * @generated from enum value: PERSISTENCY_UNKNOWN = 0;
   */
  PERSISTENCY_UNKNOWN = 0,

  /**
   * @generated from enum value: PERSISTENT = 1;
   */
  PERSISTENT = 1,

  /**
   * @generated from enum value: CACHE = 2;
   */
  CACHE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(VolumeRequest_PersistencyKind)
proto3.util.setEnumType(VolumeRequest_PersistencyKind, "namespace.cloud.compute.v1beta.VolumeRequest.PersistencyKind", [
  { no: 0, name: "PERSISTENCY_UNKNOWN" },
  { no: 1, name: "PERSISTENT" },
  { no: 2, name: "CACHE" },
]);

/**
 * @generated from message namespace.cloud.compute.v1beta.GetInstanceMetricsRequest
 */
export class GetInstanceMetricsRequest extends Message<GetInstanceMetricsRequest> {
  /**
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  /**
   * If set, only metrics data on or after this timestamp will be returned.
   *
   * Note: In JSON format, the Timestamp type is encoded as a string in the
   * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
   *
   * @generated from field: google.protobuf.Timestamp start_timestamp = 2;
   */
  startTimestamp?: Timestamp;

  /**
   * If set, only metrics data up to this timestamp will be returned.
   *
   * Note: In JSON format, the Timestamp type is encoded as a string in the
   * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
   *
   * @generated from field: google.protobuf.Timestamp end_timestamp = 3;
   */
  endTimestamp?: Timestamp;

  /**
   * Specifies which metrics should be returned.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.GetInstanceMetricsRequest.MetricResource metric_resource = 4;
   */
  metricResource: GetInstanceMetricsRequest_MetricResource[] = [];

  constructor(data?: PartialMessage<GetInstanceMetricsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetInstanceMetricsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_timestamp", kind: "message", T: Timestamp },
    { no: 3, name: "end_timestamp", kind: "message", T: Timestamp },
    { no: 4, name: "metric_resource", kind: "enum", T: proto3.getEnumType(GetInstanceMetricsRequest_MetricResource), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetInstanceMetricsRequest {
    return new GetInstanceMetricsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetInstanceMetricsRequest {
    return new GetInstanceMetricsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetInstanceMetricsRequest {
    return new GetInstanceMetricsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetInstanceMetricsRequest | PlainMessage<GetInstanceMetricsRequest> | undefined, b: GetInstanceMetricsRequest | PlainMessage<GetInstanceMetricsRequest> | undefined): boolean {
    return proto3.util.equals(GetInstanceMetricsRequest, a, b);
  }
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.GetInstanceMetricsRequest.MetricResource
 */
export enum GetInstanceMetricsRequest_MetricResource {
  /**
   * @generated from enum value: METRIC_UNSPECIFIED = 0;
   */
  METRIC_UNSPECIFIED = 0,

  /**
   * CPU usage.
   * Provides the metrics:
   * "cpu_max" (Doubles, 0..100):
   *    For each time interval, CPU utilization of the most utilized CPU.
   * "cpu_avg" (Doubles, 0 ..100):
   *    For each time interval, average CPU utilization between all CPUs.
   *
   * @generated from enum value: CPU = 1;
   */
  CPU = 1,

  /**
   * CPU usage per CPU.
   * For each CPU <n> (n = 0 .. number of CPUs - 1), provides the metrics:
   * "cpu_<n>" (Doubles, 0..100):
   *    CPU Utilization in the time interval for CPU <n>.
   *
   * @generated from enum value: CPU_BREAKDOWN = 2;
   */
  CPU_BREAKDOWN = 2,

  /**
   * IO wait time percentage.
   * Provides the metrics:
   * "io_wait_max" (Doubles, 0..100):
   *   For each time interval, max percentage of time spent waiting on IO
   *   between the CPUs.
   * "io_wait_avg" (Doubles, 0..100):
   *   For each time interval, average percentage of time all CPUs spent
   *   waiting on IO.
   *
   * @generated from enum value: IO_WAIT = 3;
   */
  IO_WAIT = 3,

  /**
   * Memory usage.
   * Provides the metrics:
   * "mem_available" (Integers, in bytes):
   *   Available memory size, in bytes.
   * "mem_used" (Integers, in bytes):
   *   Used memory size, in bytes.
   *
   * @generated from enum value: MEMORY = 4;
   */
  MEMORY = 4,

  /**
   * Storage information.
   * For each mounted volume <mountpoint>, provides the metrics:
   * "storage_used_percent_<mountpoint>" (Doubles, 0..100):
   *   Percentage of available storage capacity that is in use.
   *   "/" is the root ephemeral storage mountpoint.
   *   Other mountpoints are caches.
   *
   * @generated from enum value: STORAGE = 5;
   */
  STORAGE = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(GetInstanceMetricsRequest_MetricResource)
proto3.util.setEnumType(GetInstanceMetricsRequest_MetricResource, "namespace.cloud.compute.v1beta.GetInstanceMetricsRequest.MetricResource", [
  { no: 0, name: "METRIC_UNSPECIFIED" },
  { no: 1, name: "CPU" },
  { no: 2, name: "CPU_BREAKDOWN" },
  { no: 3, name: "IO_WAIT" },
  { no: 4, name: "MEMORY" },
  { no: 5, name: "STORAGE" },
]);

/**
 * @generated from message namespace.cloud.compute.v1beta.GetInstanceMetricsResponse
 */
export class GetInstanceMetricsResponse extends Message<GetInstanceMetricsResponse> {
  /**
   * The requested metrics will be returned in one or more time series.
   * The assignment of metrics to time series is implementation defined and
   * can change over time, so the client should iterate all time_series when
   * looking for a particular metric.
   *
   * @generated from field: repeated namespace.stdlib.TimeSeries time_series = 1;
   */
  timeSeries: TimeSeries[] = [];

  constructor(data?: PartialMessage<GetInstanceMetricsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetInstanceMetricsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "time_series", kind: "message", T: TimeSeries, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetInstanceMetricsResponse {
    return new GetInstanceMetricsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetInstanceMetricsResponse {
    return new GetInstanceMetricsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetInstanceMetricsResponse {
    return new GetInstanceMetricsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetInstanceMetricsResponse | PlainMessage<GetInstanceMetricsResponse> | undefined, b: GetInstanceMetricsResponse | PlainMessage<GetInstanceMetricsResponse> | undefined): boolean {
    return proto3.util.equals(GetInstanceMetricsResponse, a, b);
  }
}

/**
 * Used as a error detail.
 *
 * @generated from message namespace.cloud.compute.v1beta.ResourceLimitsError
 */
export class ResourceLimitsError extends Message<ResourceLimitsError> {
  /**
   * @generated from field: string description = 5;
   */
  description = "";

  /**
   * @generated from field: namespace.cloud.compute.v1beta.ResourceLimitsError.LimitKind kind = 4;
   */
  kind = ResourceLimitsError_LimitKind.LIMIT_KIND_UNKNOWN;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.ResourceLimitsError.Resource requested = 1;
   */
  requested?: ResourceLimitsError_Resource;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.ResourceLimitsError.Resource used = 2;
   */
  used?: ResourceLimitsError_Resource;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.ResourceLimitsError.Resource limits = 3;
   */
  limits?: ResourceLimitsError_Resource;

  constructor(data?: PartialMessage<ResourceLimitsError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ResourceLimitsError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "kind", kind: "enum", T: proto3.getEnumType(ResourceLimitsError_LimitKind) },
    { no: 1, name: "requested", kind: "message", T: ResourceLimitsError_Resource },
    { no: 2, name: "used", kind: "message", T: ResourceLimitsError_Resource },
    { no: 3, name: "limits", kind: "message", T: ResourceLimitsError_Resource },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceLimitsError {
    return new ResourceLimitsError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceLimitsError {
    return new ResourceLimitsError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceLimitsError {
    return new ResourceLimitsError().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceLimitsError | PlainMessage<ResourceLimitsError> | undefined, b: ResourceLimitsError | PlainMessage<ResourceLimitsError> | undefined): boolean {
    return proto3.util.equals(ResourceLimitsError, a, b);
  }
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.ResourceLimitsError.LimitKind
 */
export enum ResourceLimitsError_LimitKind {
  /**
   * @generated from enum value: LIMIT_KIND_UNKNOWN = 0;
   */
  LIMIT_KIND_UNKNOWN = 0,

  /**
   * @generated from enum value: CPU_MEMORY_LIMIT = 1;
   */
  CPU_MEMORY_LIMIT = 1,

  /**
   * @generated from enum value: INSTANCE_COUNT_LIMIT = 2;
   */
  INSTANCE_COUNT_LIMIT = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ResourceLimitsError_LimitKind)
proto3.util.setEnumType(ResourceLimitsError_LimitKind, "namespace.cloud.compute.v1beta.ResourceLimitsError.LimitKind", [
  { no: 0, name: "LIMIT_KIND_UNKNOWN" },
  { no: 1, name: "CPU_MEMORY_LIMIT" },
  { no: 2, name: "INSTANCE_COUNT_LIMIT" },
]);

/**
 * @generated from message namespace.cloud.compute.v1beta.ResourceLimitsError.Resource
 */
export class ResourceLimitsError_Resource extends Message<ResourceLimitsError_Resource> {
  /**
   * @generated from field: int32 virtual_cpu = 1;
   */
  virtualCpu = 0;

  /**
   * @generated from field: int32 memory_megabytes = 2;
   */
  memoryMegabytes = 0;

  /**
   * @generated from field: int32 instance_count = 3;
   */
  instanceCount = 0;

  constructor(data?: PartialMessage<ResourceLimitsError_Resource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ResourceLimitsError.Resource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "virtual_cpu", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "memory_megabytes", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "instance_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceLimitsError_Resource {
    return new ResourceLimitsError_Resource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceLimitsError_Resource {
    return new ResourceLimitsError_Resource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceLimitsError_Resource {
    return new ResourceLimitsError_Resource().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceLimitsError_Resource | PlainMessage<ResourceLimitsError_Resource> | undefined, b: ResourceLimitsError_Resource | PlainMessage<ResourceLimitsError_Resource> | undefined): boolean {
    return proto3.util.equals(ResourceLimitsError_Resource, a, b);
  }
}

/**
 * Used as a error detail.
 *
 * @generated from message namespace.cloud.compute.v1beta.UsageLimitsError
 */
export class UsageLimitsError extends Message<UsageLimitsError> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.UsageLimitsError.Usage used = 1;
   */
  used?: UsageLimitsError_Usage;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.UsageLimitsError.Usage limits = 2;
   */
  limits?: UsageLimitsError_Usage;

  constructor(data?: PartialMessage<UsageLimitsError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.UsageLimitsError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "used", kind: "message", T: UsageLimitsError_Usage },
    { no: 2, name: "limits", kind: "message", T: UsageLimitsError_Usage },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageLimitsError {
    return new UsageLimitsError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageLimitsError {
    return new UsageLimitsError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageLimitsError {
    return new UsageLimitsError().fromJsonString(jsonString, options);
  }

  static equals(a: UsageLimitsError | PlainMessage<UsageLimitsError> | undefined, b: UsageLimitsError | PlainMessage<UsageLimitsError> | undefined): boolean {
    return proto3.util.equals(UsageLimitsError, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.UsageLimitsError.Usage
 */
export class UsageLimitsError_Usage extends Message<UsageLimitsError_Usage> {
  /**
   * @generated from field: int64 compute_unit_minutes = 1;
   */
  computeUnitMinutes = protoInt64.zero;

  /**
   * @generated from field: int64 compute_wall_seconds = 2;
   */
  computeWallSeconds = protoInt64.zero;

  constructor(data?: PartialMessage<UsageLimitsError_Usage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.UsageLimitsError.Usage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "compute_unit_minutes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "compute_wall_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageLimitsError_Usage {
    return new UsageLimitsError_Usage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageLimitsError_Usage {
    return new UsageLimitsError_Usage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageLimitsError_Usage {
    return new UsageLimitsError_Usage().fromJsonString(jsonString, options);
  }

  static equals(a: UsageLimitsError_Usage | PlainMessage<UsageLimitsError_Usage> | undefined, b: UsageLimitsError_Usage | PlainMessage<UsageLimitsError_Usage> | undefined): boolean {
    return proto3.util.equals(UsageLimitsError_Usage, a, b);
  }
}

/**
 * Used as a error detail.
 *
 * @generated from message namespace.cloud.compute.v1beta.PlatformNotAllowedError
 */
export class PlatformNotAllowedError extends Message<PlatformNotAllowedError> {
  /**
   * @generated from field: string requested_platform = 1;
   */
  requestedPlatform = "";

  /**
   * @generated from field: repeated string allowed_platforms = 2;
   */
  allowedPlatforms: string[] = [];

  constructor(data?: PartialMessage<PlatformNotAllowedError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.PlatformNotAllowedError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requested_platform", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "allowed_platforms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlatformNotAllowedError {
    return new PlatformNotAllowedError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlatformNotAllowedError {
    return new PlatformNotAllowedError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlatformNotAllowedError {
    return new PlatformNotAllowedError().fromJsonString(jsonString, options);
  }

  static equals(a: PlatformNotAllowedError | PlainMessage<PlatformNotAllowedError> | undefined, b: PlatformNotAllowedError | PlainMessage<PlatformNotAllowedError> | undefined): boolean {
    return proto3.util.equals(PlatformNotAllowedError, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetNetworkConfigurationRequest
 */
export class GetNetworkConfigurationRequest extends Message<GetNetworkConfigurationRequest> {
  constructor(data?: PartialMessage<GetNetworkConfigurationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetNetworkConfigurationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNetworkConfigurationRequest {
    return new GetNetworkConfigurationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNetworkConfigurationRequest {
    return new GetNetworkConfigurationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNetworkConfigurationRequest {
    return new GetNetworkConfigurationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetNetworkConfigurationRequest | PlainMessage<GetNetworkConfigurationRequest> | undefined, b: GetNetworkConfigurationRequest | PlainMessage<GetNetworkConfigurationRequest> | undefined): boolean {
    return proto3.util.equals(GetNetworkConfigurationRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse
 */
export class GetNetworkConfigurationResponse extends Message<GetNetworkConfigurationResponse> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.Egress egress = 1;
   */
  egress?: GetNetworkConfigurationResponse_Egress;

  constructor(data?: PartialMessage<GetNetworkConfigurationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "egress", kind: "message", T: GetNetworkConfigurationResponse_Egress },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNetworkConfigurationResponse {
    return new GetNetworkConfigurationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNetworkConfigurationResponse {
    return new GetNetworkConfigurationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNetworkConfigurationResponse {
    return new GetNetworkConfigurationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetNetworkConfigurationResponse | PlainMessage<GetNetworkConfigurationResponse> | undefined, b: GetNetworkConfigurationResponse | PlainMessage<GetNetworkConfigurationResponse> | undefined): boolean {
    return proto3.util.equals(GetNetworkConfigurationResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.Egress
 */
export class GetNetworkConfigurationResponse_Egress extends Message<GetNetworkConfigurationResponse_Egress> {
  /**
   * Possible source addresses used by instances running in this workspace
   * (tenant).
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.CIDR egress_cidrs = 1;
   */
  egressCidrs: GetNetworkConfigurationResponse_CIDR[] = [];

  constructor(data?: PartialMessage<GetNetworkConfigurationResponse_Egress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.Egress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "egress_cidrs", kind: "message", T: GetNetworkConfigurationResponse_CIDR, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNetworkConfigurationResponse_Egress {
    return new GetNetworkConfigurationResponse_Egress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNetworkConfigurationResponse_Egress {
    return new GetNetworkConfigurationResponse_Egress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNetworkConfigurationResponse_Egress {
    return new GetNetworkConfigurationResponse_Egress().fromJsonString(jsonString, options);
  }

  static equals(a: GetNetworkConfigurationResponse_Egress | PlainMessage<GetNetworkConfigurationResponse_Egress> | undefined, b: GetNetworkConfigurationResponse_Egress | PlainMessage<GetNetworkConfigurationResponse_Egress> | undefined): boolean {
    return proto3.util.equals(GetNetworkConfigurationResponse_Egress, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.CIDR
 */
export class GetNetworkConfigurationResponse_CIDR extends Message<GetNetworkConfigurationResponse_CIDR> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.CIDR.Kind kind = 1;
   */
  kind = GetNetworkConfigurationResponse_CIDR_Kind.KIND_UNKNOWN;

  /**
   * @generated from field: string cidr = 2;
   */
  cidr = "";

  constructor(data?: PartialMessage<GetNetworkConfigurationResponse_CIDR>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.CIDR";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(GetNetworkConfigurationResponse_CIDR_Kind) },
    { no: 2, name: "cidr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNetworkConfigurationResponse_CIDR {
    return new GetNetworkConfigurationResponse_CIDR().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNetworkConfigurationResponse_CIDR {
    return new GetNetworkConfigurationResponse_CIDR().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNetworkConfigurationResponse_CIDR {
    return new GetNetworkConfigurationResponse_CIDR().fromJsonString(jsonString, options);
  }

  static equals(a: GetNetworkConfigurationResponse_CIDR | PlainMessage<GetNetworkConfigurationResponse_CIDR> | undefined, b: GetNetworkConfigurationResponse_CIDR | PlainMessage<GetNetworkConfigurationResponse_CIDR> | undefined): boolean {
    return proto3.util.equals(GetNetworkConfigurationResponse_CIDR, a, b);
  }
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.CIDR.Kind
 */
export enum GetNetworkConfigurationResponse_CIDR_Kind {
  /**
   * @generated from enum value: KIND_UNKNOWN = 0;
   */
  KIND_UNKNOWN = 0,

  /**
   * @generated from enum value: NAMESPACE_MANAGED = 1;
   */
  NAMESPACE_MANAGED = 1,

  /**
   * @generated from enum value: EXTERNAL_TRANSIT_PROVIDER = 2;
   */
  EXTERNAL_TRANSIT_PROVIDER = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(GetNetworkConfigurationResponse_CIDR_Kind)
proto3.util.setEnumType(GetNetworkConfigurationResponse_CIDR_Kind, "namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.CIDR.Kind", [
  { no: 0, name: "KIND_UNKNOWN" },
  { no: 1, name: "NAMESPACE_MANAGED" },
  { no: 2, name: "EXTERNAL_TRANSIT_PROVIDER" },
]);

/**
 * @generated from message namespace.cloud.compute.v1beta.GetSSHConfigRequest
 */
export class GetSSHConfigRequest extends Message<GetSSHConfigRequest> {
  /**
   * Required: which instance to provide and SSH configuration for.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  /**
   * Optional: Specify a container name to connect to. The resulting connection endpoint will open a session in that container, if present.
   *
   * @generated from field: string target_container = 2;
   */
  targetContainer = "";

  constructor(data?: PartialMessage<GetSSHConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetSSHConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "target_container", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSSHConfigRequest {
    return new GetSSHConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSSHConfigRequest {
    return new GetSSHConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSSHConfigRequest {
    return new GetSSHConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSSHConfigRequest | PlainMessage<GetSSHConfigRequest> | undefined, b: GetSSHConfigRequest | PlainMessage<GetSSHConfigRequest> | undefined): boolean {
    return proto3.util.equals(GetSSHConfigRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetSSHConfigResponse
 */
export class GetSSHConfigResponse extends Message<GetSSHConfigResponse> {
  /**
   * If set, this private key can be used to establish an SSH session to the instance.
   * Any private key returned here has limited access rights, restricted to a single instance.
   *
   * @generated from field: bytes ssh_private_key = 1;
   */
  sshPrivateKey = new Uint8Array(0);

  /**
   * Which username to use when establishing an SSH session.
   * E.g. You can start a session from a terminal using `ssh <username>@<endpoint>`.
   *
   * @generated from field: string username = 2;
   */
  username = "";

  /**
   * This SSH endpoint can be used to establish an SSH session with the instance.
   * Make sure to also configure the corresponding username.
   *
   * @generated from field: string endpoint = 3;
   */
  endpoint = "";

  constructor(data?: PartialMessage<GetSSHConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetSSHConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ssh_private_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSSHConfigResponse {
    return new GetSSHConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSSHConfigResponse {
    return new GetSSHConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSSHConfigResponse {
    return new GetSSHConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSSHConfigResponse | PlainMessage<GetSSHConfigResponse> | undefined, b: GetSSHConfigResponse | PlainMessage<GetSSHConfigResponse> | undefined): boolean {
    return proto3.util.equals(GetSSHConfigResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ReleaseUniqueTagRequest
 */
export class ReleaseUniqueTagRequest extends Message<ReleaseUniqueTagRequest> {
  /**
   * The name of the unique tag to release.
   *
   * @generated from field: string unique_tag = 1;
   */
  uniqueTag = "";

  /**
   * If set, only release the unique tag if the currently associated instance ID matches this constraint.
   *
   * When running a container with `nsc_state_path` set, the parent instance ID is available via the environment variable NSC_INSTANCE_ID.
   *
   * @generated from field: namespace.stdlib.StringMatcher if_instance_id = 2;
   */
  ifInstanceId?: StringMatcher;

  constructor(data?: PartialMessage<ReleaseUniqueTagRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ReleaseUniqueTagRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "unique_tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "if_instance_id", kind: "message", T: StringMatcher },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReleaseUniqueTagRequest {
    return new ReleaseUniqueTagRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReleaseUniqueTagRequest {
    return new ReleaseUniqueTagRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReleaseUniqueTagRequest {
    return new ReleaseUniqueTagRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReleaseUniqueTagRequest | PlainMessage<ReleaseUniqueTagRequest> | undefined, b: ReleaseUniqueTagRequest | PlainMessage<ReleaseUniqueTagRequest> | undefined): boolean {
    return proto3.util.equals(ReleaseUniqueTagRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ReleaseUniqueTagResponse
 */
export class ReleaseUniqueTagResponse extends Message<ReleaseUniqueTagResponse> {
  /**
   * The ID of the instance that was released from the tag.
   * If no instance was released, this field is not set.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId = "";

  constructor(data?: PartialMessage<ReleaseUniqueTagResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ReleaseUniqueTagResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReleaseUniqueTagResponse {
    return new ReleaseUniqueTagResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReleaseUniqueTagResponse {
    return new ReleaseUniqueTagResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReleaseUniqueTagResponse {
    return new ReleaseUniqueTagResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReleaseUniqueTagResponse | PlainMessage<ReleaseUniqueTagResponse> | undefined, b: ReleaseUniqueTagResponse | PlainMessage<ReleaseUniqueTagResponse> | undefined): boolean {
    return proto3.util.equals(ReleaseUniqueTagResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.OptimizeImageRequest
 */
export class OptimizeImageRequest extends Message<OptimizeImageRequest> {
  /**
   * @generated from field: string image_ref = 1;
   */
  imageRef = "";

  /**
   * @generated from field: string site = 2;
   */
  site = "";

  constructor(data?: PartialMessage<OptimizeImageRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.OptimizeImageRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "image_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "site", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptimizeImageRequest {
    return new OptimizeImageRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptimizeImageRequest {
    return new OptimizeImageRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptimizeImageRequest {
    return new OptimizeImageRequest().fromJsonString(jsonString, options);
  }

  static equals(a: OptimizeImageRequest | PlainMessage<OptimizeImageRequest> | undefined, b: OptimizeImageRequest | PlainMessage<OptimizeImageRequest> | undefined): boolean {
    return proto3.util.equals(OptimizeImageRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.OptimizeImageProgress
 */
export class OptimizeImageProgress extends Message<OptimizeImageProgress> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.OptimizeImageProgress.Status status = 1;
   */
  status = OptimizeImageProgress_Status.STATUS_UNKNOWN;

  /**
   * @generated from field: string baker_instance_id = 2;
   */
  bakerInstanceId = "";

  constructor(data?: PartialMessage<OptimizeImageProgress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.OptimizeImageProgress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(OptimizeImageProgress_Status) },
    { no: 2, name: "baker_instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptimizeImageProgress {
    return new OptimizeImageProgress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptimizeImageProgress {
    return new OptimizeImageProgress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptimizeImageProgress {
    return new OptimizeImageProgress().fromJsonString(jsonString, options);
  }

  static equals(a: OptimizeImageProgress | PlainMessage<OptimizeImageProgress> | undefined, b: OptimizeImageProgress | PlainMessage<OptimizeImageProgress> | undefined): boolean {
    return proto3.util.equals(OptimizeImageProgress, a, b);
  }
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.OptimizeImageProgress.Status
 */
export enum OptimizeImageProgress_Status {
  /**
   * @generated from enum value: STATUS_UNKNOWN = 0;
   */
  STATUS_UNKNOWN = 0,

  /**
   * @generated from enum value: PREPARING = 1;
   */
  PREPARING = 1,

  /**
   * @generated from enum value: STARTING = 2;
   */
  STARTING = 2,

  /**
   * @generated from enum value: BAKING = 3;
   */
  BAKING = 3,

  /**
   * @generated from enum value: DONE = 4;
   */
  DONE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(OptimizeImageProgress_Status)
proto3.util.setEnumType(OptimizeImageProgress_Status, "namespace.cloud.compute.v1beta.OptimizeImageProgress.Status", [
  { no: 0, name: "STATUS_UNKNOWN" },
  { no: 1, name: "PREPARING" },
  { no: 2, name: "STARTING" },
  { no: 3, name: "BAKING" },
  { no: 4, name: "DONE" },
]);

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceEventMetadata
 */
export class InstanceEventMetadata extends Message<InstanceEventMetadata> {
  /**
   * @generated from field: google.protobuf.Timestamp emitted_at = 1;
   */
  emittedAt?: Timestamp;

  /**
   * @generated from field: string tenant_id = 2;
   */
  tenantId = "";

  /**
   * @generated from field: string instance_id = 3;
   */
  instanceId = "";

  /**
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata.Status status = 4;
   */
  status = InstanceMetadata_Status.STATUS_UNKNOWN;

  /**
   * @generated from field: repeated namespace.stdlib.Label labels = 5;
   */
  labels: Label[] = [];

  constructor(data?: PartialMessage<InstanceEventMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceEventMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "emitted_at", kind: "message", T: Timestamp },
    { no: 2, name: "tenant_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "status", kind: "enum", T: proto3.getEnumType(InstanceMetadata_Status) },
    { no: 5, name: "labels", kind: "message", T: Label, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceEventMetadata {
    return new InstanceEventMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceEventMetadata {
    return new InstanceEventMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceEventMetadata {
    return new InstanceEventMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceEventMetadata | PlainMessage<InstanceEventMetadata> | undefined, b: InstanceEventMetadata | PlainMessage<InstanceEventMetadata> | undefined): boolean {
    return proto3.util.equals(InstanceEventMetadata, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListInstanceNotificationsRequest
 */
export class ListInstanceNotificationsRequest extends Message<ListInstanceNotificationsRequest> {
  /**
   * Optional filter to match instance IDs. If not set, returns events for
   * all instances.
   *
   * @generated from field: namespace.stdlib.StringMatcher instance_ids = 1;
   */
  instanceIds?: StringMatcher;

  /**
   * The maximum number of events to return. The list of events returned is
   * always capped to an internal number.
   *
   * @generated from field: int64 limit = 2;
   */
  limit = protoInt64.zero;

  /**
   * If set to true, only pending events that have not yet been delivered
   * are returned.
   *
   * @generated from field: bool only_pending_events = 3;
   */
  onlyPendingEvents = false;

  constructor(data?: PartialMessage<ListInstanceNotificationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListInstanceNotificationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_ids", kind: "message", T: StringMatcher },
    { no: 2, name: "limit", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "only_pending_events", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInstanceNotificationsRequest {
    return new ListInstanceNotificationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInstanceNotificationsRequest {
    return new ListInstanceNotificationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInstanceNotificationsRequest {
    return new ListInstanceNotificationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListInstanceNotificationsRequest | PlainMessage<ListInstanceNotificationsRequest> | undefined, b: ListInstanceNotificationsRequest | PlainMessage<ListInstanceNotificationsRequest> | undefined): boolean {
    return proto3.util.equals(ListInstanceNotificationsRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListInstanceNotificationsResponse
 */
export class ListInstanceNotificationsResponse extends Message<ListInstanceNotificationsResponse> {
  /**
   * The list of events, ordered by emitted time in descending order (most
   * recent first). Each instance has at most one event in the response.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.InstanceEventMetadata events = 1;
   */
  events: InstanceEventMetadata[] = [];

  constructor(data?: PartialMessage<ListInstanceNotificationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListInstanceNotificationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: InstanceEventMetadata, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInstanceNotificationsResponse {
    return new ListInstanceNotificationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInstanceNotificationsResponse {
    return new ListInstanceNotificationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInstanceNotificationsResponse {
    return new ListInstanceNotificationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListInstanceNotificationsResponse | PlainMessage<ListInstanceNotificationsResponse> | undefined, b: ListInstanceNotificationsResponse | PlainMessage<ListInstanceNotificationsResponse> | undefined): boolean {
    return proto3.util.equals(ListInstanceNotificationsResponse, a, b);
  }
}

