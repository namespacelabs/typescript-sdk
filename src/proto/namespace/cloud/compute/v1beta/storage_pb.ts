// @generated by protoc-gen-es v1.3.0 with parameter "target=js+ts+dts"
// @generated from file proto/namespace/cloud/compute/v1beta/storage.proto (package namespace.cloud.compute.v1beta, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from message namespace.cloud.compute.v1beta.GetCacheVolumeRequest
 */
export class GetCacheVolumeRequest extends Message<GetCacheVolumeRequest> {
  /**
   * The unique identifier of this cache volume instance. Within a single cache volume tag,
   * multiple cache volume generations may exist, and each one is uniquely identified by this id.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetCacheVolumeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetCacheVolumeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCacheVolumeRequest {
    return new GetCacheVolumeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCacheVolumeRequest {
    return new GetCacheVolumeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCacheVolumeRequest {
    return new GetCacheVolumeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetCacheVolumeRequest | PlainMessage<GetCacheVolumeRequest> | undefined, b: GetCacheVolumeRequest | PlainMessage<GetCacheVolumeRequest> | undefined): boolean {
    return proto3.util.equals(GetCacheVolumeRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetCacheVolumeResponse
 */
export class GetCacheVolumeResponse extends Message<GetCacheVolumeResponse> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.CacheVolume cache_volume = 1;
   */
  cacheVolume?: CacheVolume;

  constructor(data?: PartialMessage<GetCacheVolumeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetCacheVolumeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cache_volume", kind: "message", T: CacheVolume },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCacheVolumeResponse {
    return new GetCacheVolumeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCacheVolumeResponse {
    return new GetCacheVolumeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCacheVolumeResponse {
    return new GetCacheVolumeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetCacheVolumeResponse | PlainMessage<GetCacheVolumeResponse> | undefined, b: GetCacheVolumeResponse | PlainMessage<GetCacheVolumeResponse> | undefined): boolean {
    return proto3.util.equals(GetCacheVolumeResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListCacheVolumesRequest
 */
export class ListCacheVolumesRequest extends Message<ListCacheVolumesRequest> {
  constructor(data?: PartialMessage<ListCacheVolumesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListCacheVolumesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCacheVolumesRequest {
    return new ListCacheVolumesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCacheVolumesRequest {
    return new ListCacheVolumesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCacheVolumesRequest {
    return new ListCacheVolumesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListCacheVolumesRequest | PlainMessage<ListCacheVolumesRequest> | undefined, b: ListCacheVolumesRequest | PlainMessage<ListCacheVolumesRequest> | undefined): boolean {
    return proto3.util.equals(ListCacheVolumesRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListCacheVolumesResponse
 */
export class ListCacheVolumesResponse extends Message<ListCacheVolumesResponse> {
  /**
   * @generated from field: repeated namespace.cloud.compute.v1beta.CacheVolume cache_volume = 1;
   */
  cacheVolume: CacheVolume[] = [];

  constructor(data?: PartialMessage<ListCacheVolumesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListCacheVolumesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cache_volume", kind: "message", T: CacheVolume, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCacheVolumesResponse {
    return new ListCacheVolumesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCacheVolumesResponse {
    return new ListCacheVolumesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCacheVolumesResponse {
    return new ListCacheVolumesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListCacheVolumesResponse | PlainMessage<ListCacheVolumesResponse> | undefined, b: ListCacheVolumesResponse | PlainMessage<ListCacheVolumesResponse> | undefined): boolean {
    return proto3.util.equals(ListCacheVolumesResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CacheVolume
 */
export class CacheVolume extends Message<CacheVolume> {
  /**
   * The unique identifier of this cache volume instance. Within a single cache volume tag,
   * multiple cache volume generations may exist, and each one is uniquely identified by this id.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Which volume tag does this volume belong to?
   *
   * @generated from field: string tag = 2;
   */
  tag = "";

  /**
   * Metadata includes the lifecycle timestamps of the volume, as well as any
   * other values provided at creation time, e.g. the volume size.
   *
   * @generated from field: namespace.cloud.compute.v1beta.VolumeMetadata metadata = 3;
   */
  metadata?: VolumeMetadata;

  /**
   * Volumes are attached once to instances. Attachment captures the lifecycle
   * of that relationship, including which compute instance the volume was attached to,
   * when it was attached, and detached.
   *
   * @generated from field: namespace.cloud.compute.v1beta.VolumeAttachment attachment = 4;
   */
  attachment?: VolumeAttachment;

  constructor(data?: PartialMessage<CacheVolume>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CacheVolume";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "metadata", kind: "message", T: VolumeMetadata },
    { no: 4, name: "attachment", kind: "message", T: VolumeAttachment },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CacheVolume {
    return new CacheVolume().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CacheVolume {
    return new CacheVolume().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CacheVolume {
    return new CacheVolume().fromJsonString(jsonString, options);
  }

  static equals(a: CacheVolume | PlainMessage<CacheVolume> | undefined, b: CacheVolume | PlainMessage<CacheVolume> | undefined): boolean {
    return proto3.util.equals(CacheVolume, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.VolumeMetadata
 */
export class VolumeMetadata extends Message<VolumeMetadata> {
  /**
   * The timestamp of when the volume was created (in UTC).
   *
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * The timestamp of when the volume was destroyed (in UTC). Not set if the
   * volume is still alive.
   *
   * @generated from field: google.protobuf.Timestamp destroyed_at = 2;
   */
  destroyedAt?: Timestamp;

  /**
   * The requested size of the volume in megabytes.
   *
   * @generated from field: uint32 size_mb = 3;
   */
  sizeMb = 0;

  /**
   * Which state is this volume in right now?
   *
   * @generated from field: namespace.cloud.compute.v1beta.VolumeMetadata.State state = 4;
   */
  state = VolumeMetadata_State.UNKNOWN;

  constructor(data?: PartialMessage<VolumeMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.VolumeMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "created_at", kind: "message", T: Timestamp },
    { no: 2, name: "destroyed_at", kind: "message", T: Timestamp },
    { no: 3, name: "size_mb", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "state", kind: "enum", T: proto3.getEnumType(VolumeMetadata_State) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VolumeMetadata {
    return new VolumeMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VolumeMetadata {
    return new VolumeMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VolumeMetadata {
    return new VolumeMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: VolumeMetadata | PlainMessage<VolumeMetadata> | undefined, b: VolumeMetadata | PlainMessage<VolumeMetadata> | undefined): boolean {
    return proto3.util.equals(VolumeMetadata, a, b);
  }
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.VolumeMetadata.State
 */
export enum VolumeMetadata_State {
  /**
   * @generated from enum value: STATE_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * The volume is currently attached to an instance. Once detached, it gets
   * stored at rest and becomes a candidate to clone new Cache Volumes from.
   *
   * @generated from enum value: STATE_IN_USE = 1;
   */
  IN_USE = 1,

  /**
   * This volume is a candidate to clone new Cache Volumes from.
   *
   * @generated from enum value: STATE_AT_REST = 2;
   */
  AT_REST = 2,

  /**
   * This volume is no longer a candidate to clone new Cache Volumes from.
   * It has been superceded by a newer candidate.
   *
   * @generated from enum value: STATE_EXPIRED = 3;
   */
  EXPIRED = 3,

  /**
   * This volume was used by an instance, but was not promoted to be a candidate
   * for future clones (e.g. because that instance's workload did not complete successfully).
   *
   * @generated from enum value: STATE_ABANDONED = 4;
   */
  ABANDONED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(VolumeMetadata_State)
proto3.util.setEnumType(VolumeMetadata_State, "namespace.cloud.compute.v1beta.VolumeMetadata.State", [
  { no: 0, name: "STATE_UNKNOWN" },
  { no: 1, name: "STATE_IN_USE" },
  { no: 2, name: "STATE_AT_REST" },
  { no: 3, name: "STATE_EXPIRED" },
  { no: 4, name: "STATE_ABANDONED" },
]);

/**
 * @generated from message namespace.cloud.compute.v1beta.VolumeAttachment
 */
export class VolumeAttachment extends Message<VolumeAttachment> {
  /**
   * The ID of the compute instance that this volume is attached to.
   * A volume can be attached to at most one instance at a time.
   * Empty, if the volume is not attached to any compute instance.
   *
   * @generated from field: string attached_to = 1;
   */
  attachedTo = "";

  /**
   * Deprecated, use `attached_at` instead.
   *
   * @generated from field: google.protobuf.Timestamp last_attached_at = 2 [deprecated = true];
   * @deprecated
   */
  lastAttachedAt?: Timestamp;

  /**
   * Deprecated, use `detached_at` instead.
   *
   * @generated from field: google.protobuf.Timestamp last_detached_at = 3 [deprecated = true];
   * @deprecated
   */
  lastDetachedAt?: Timestamp;

  /**
   * The timestamp of when the volume was attached to the compute instance (in UTC).
   *
   * @generated from field: google.protobuf.Timestamp attached_at = 4;
   */
  attachedAt?: Timestamp;

  /**
   * The amount of data already stored on the volume when attaching it in megabytes.
   *
   * @generated from field: uint32 used_mb_when_attached = 5;
   */
  usedMbWhenAttached = 0;

  /**
   * The timestamp of when the volume was detached from the compute instance (in UTC).
   * If the volume is still attached to the instance, this field will not be set.
   *
   * @generated from field: google.protobuf.Timestamp detached_at = 6;
   */
  detachedAt?: Timestamp;

  /**
   * The amount of data stored on the volume when detaching it in megabytes.
   * If the volume is still attached to the instance, this field will not be set.
   *
   * @generated from field: uint32 used_mb_when_detached = 7;
   */
  usedMbWhenDetached = 0;

  /**
   * If unset, Container Image caching is not enabled.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerImageCache container_image_cache = 8;
   */
  containerImageCache?: ContainerImageCache;

  /**
   * Utilization metadata per path in the cache volume.
   * This data is only populated after the volume is detached.
   *
   * To enable path utilization tracking, provide `CacheMetadata` to Namespace by
   * producing a JSON file inside the Cache Volume at the path `.ns/cache-metadata.json`.
   *
   * @generated from field: map<string, namespace.cloud.compute.v1beta.PathUtilization> path_utilization = 9;
   */
  pathUtilization: { [key: string]: PathUtilization } = {};

  constructor(data?: PartialMessage<VolumeAttachment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.VolumeAttachment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "attached_to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "last_attached_at", kind: "message", T: Timestamp },
    { no: 3, name: "last_detached_at", kind: "message", T: Timestamp },
    { no: 4, name: "attached_at", kind: "message", T: Timestamp },
    { no: 5, name: "used_mb_when_attached", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "detached_at", kind: "message", T: Timestamp },
    { no: 7, name: "used_mb_when_detached", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "container_image_cache", kind: "message", T: ContainerImageCache },
    { no: 9, name: "path_utilization", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: PathUtilization} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VolumeAttachment {
    return new VolumeAttachment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VolumeAttachment {
    return new VolumeAttachment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VolumeAttachment {
    return new VolumeAttachment().fromJsonString(jsonString, options);
  }

  static equals(a: VolumeAttachment | PlainMessage<VolumeAttachment> | undefined, b: VolumeAttachment | PlainMessage<VolumeAttachment> | undefined): boolean {
    return proto3.util.equals(VolumeAttachment, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerImageCache
 */
export class ContainerImageCache extends Message<ContainerImageCache> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  constructor(data?: PartialMessage<ContainerImageCache>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerImageCache";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerImageCache {
    return new ContainerImageCache().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerImageCache {
    return new ContainerImageCache().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerImageCache {
    return new ContainerImageCache().fromJsonString(jsonString, options);
  }

  static equals(a: ContainerImageCache | PlainMessage<ContainerImageCache> | undefined, b: ContainerImageCache | PlainMessage<ContainerImageCache> | undefined): boolean {
    return proto3.util.equals(ContainerImageCache, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.PathUtilization
 */
export class PathUtilization extends Message<PathUtilization> {
  /**
   * What framework/purpose is this cache path used for?
   *
   * @generated from field: string cache_framework = 1;
   */
  cacheFramework = "";

  /**
   * A series of bind mounts that have been applied to this cache path.
   *
   * @generated from field: repeated string mount_target = 2;
   */
  mountTarget: string[] = [];

  /**
   * Name of the system that configured this cache path usage.
   *
   * @generated from field: string source = 3;
   */
  source = "";

  /**
   * The utilization of this path in the Cache Volume in megabytes.
   *
   * @generated from field: uint64 utilization_mb = 4;
   */
  utilizationMb = protoInt64.zero;

  /**
   * When was this usage recorded.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  constructor(data?: PartialMessage<PathUtilization>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.PathUtilization";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cache_framework", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mount_target", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "utilization_mb", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "created_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PathUtilization {
    return new PathUtilization().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PathUtilization {
    return new PathUtilization().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PathUtilization {
    return new PathUtilization().fromJsonString(jsonString, options);
  }

  static equals(a: PathUtilization | PlainMessage<PathUtilization> | undefined, b: PathUtilization | PlainMessage<PathUtilization> | undefined): boolean {
    return proto3.util.equals(PathUtilization, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetVolumeTagSummaryRequest
 */
export class GetVolumeTagSummaryRequest extends Message<GetVolumeTagSummaryRequest> {
  /**
   * The name of the tag.
   *
   * @generated from field: string tag = 1;
   */
  tag = "";

  constructor(data?: PartialMessage<GetVolumeTagSummaryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetVolumeTagSummaryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVolumeTagSummaryRequest {
    return new GetVolumeTagSummaryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVolumeTagSummaryRequest {
    return new GetVolumeTagSummaryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVolumeTagSummaryRequest {
    return new GetVolumeTagSummaryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetVolumeTagSummaryRequest | PlainMessage<GetVolumeTagSummaryRequest> | undefined, b: GetVolumeTagSummaryRequest | PlainMessage<GetVolumeTagSummaryRequest> | undefined): boolean {
    return proto3.util.equals(GetVolumeTagSummaryRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetVolumeTagSummaryResponse
 */
export class GetVolumeTagSummaryResponse extends Message<GetVolumeTagSummaryResponse> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.TagSummary summary = 1;
   */
  summary?: TagSummary;

  constructor(data?: PartialMessage<GetVolumeTagSummaryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetVolumeTagSummaryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "summary", kind: "message", T: TagSummary },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVolumeTagSummaryResponse {
    return new GetVolumeTagSummaryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVolumeTagSummaryResponse {
    return new GetVolumeTagSummaryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVolumeTagSummaryResponse {
    return new GetVolumeTagSummaryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetVolumeTagSummaryResponse | PlainMessage<GetVolumeTagSummaryResponse> | undefined, b: GetVolumeTagSummaryResponse | PlainMessage<GetVolumeTagSummaryResponse> | undefined): boolean {
    return proto3.util.equals(GetVolumeTagSummaryResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListVolumeTagSummariesRequest
 */
export class ListVolumeTagSummariesRequest extends Message<ListVolumeTagSummariesRequest> {
  constructor(data?: PartialMessage<ListVolumeTagSummariesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListVolumeTagSummariesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListVolumeTagSummariesRequest {
    return new ListVolumeTagSummariesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListVolumeTagSummariesRequest {
    return new ListVolumeTagSummariesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListVolumeTagSummariesRequest {
    return new ListVolumeTagSummariesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListVolumeTagSummariesRequest | PlainMessage<ListVolumeTagSummariesRequest> | undefined, b: ListVolumeTagSummariesRequest | PlainMessage<ListVolumeTagSummariesRequest> | undefined): boolean {
    return proto3.util.equals(ListVolumeTagSummariesRequest, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListVolumeTagSummariesResponse
 */
export class ListVolumeTagSummariesResponse extends Message<ListVolumeTagSummariesResponse> {
  /**
   * @generated from field: repeated namespace.cloud.compute.v1beta.TagSummary summaries = 1;
   */
  summaries: TagSummary[] = [];

  constructor(data?: PartialMessage<ListVolumeTagSummariesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListVolumeTagSummariesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "summaries", kind: "message", T: TagSummary, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListVolumeTagSummariesResponse {
    return new ListVolumeTagSummariesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListVolumeTagSummariesResponse {
    return new ListVolumeTagSummariesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListVolumeTagSummariesResponse {
    return new ListVolumeTagSummariesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListVolumeTagSummariesResponse | PlainMessage<ListVolumeTagSummariesResponse> | undefined, b: ListVolumeTagSummariesResponse | PlainMessage<ListVolumeTagSummariesResponse> | undefined): boolean {
    return proto3.util.equals(ListVolumeTagSummariesResponse, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.TagSummary
 */
export class TagSummary extends Message<TagSummary> {
  /**
   * The name of the tag.
   *
   * @generated from field: string tag = 1;
   */
  tag = "";

  /**
   * The requested size of the volume tag in megabytes.
   *
   * @generated from field: uint32 size_mb = 2;
   */
  sizeMb = 0;

  /**
   * A series of all active generations at rest that belong to this tag.
   * These generations are candidates to clone new Cache Volumes from.
   * The list is sorted chronologically, starting with the oldest
   * available generation.
   *
   * Deprecated, use `generations` instead.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CacheVolume at_rest = 3 [deprecated = true];
   * @deprecated
   */
  atRest: CacheVolume[] = [];

  /**
   * A series of all generations in use that belong to this tag.
   * Once detached, these generations get stored at rest and become
   * candidates to clone new Cache Volumes from.
   * The list is sorted chronologically, starting with the oldest
   * available generation.
   *
   * Deprecated, use `generations` instead.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CacheVolume in_use = 5 [deprecated = true];
   * @deprecated
   */
  inUse: CacheVolume[] = [];

  /**
   * A series of generations that belong to this tag.
   * This list contains
   * - all active generations at rest
   * - all generations in use
   * - the latest expired/abandoned generations (potentially incomplete)
   * The list is sorted chronologically, starting with the oldest
   * available generation.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CacheVolume generations = 6;
   */
  generations: CacheVolume[] = [];

  /**
   * The timestamp of the first generation (in UTC). Reset when released.
   * Note: this field is not populated yet.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 4;
   */
  createdAt?: Timestamp;

  constructor(data?: PartialMessage<TagSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.TagSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "size_mb", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "at_rest", kind: "message", T: CacheVolume, repeated: true },
    { no: 5, name: "in_use", kind: "message", T: CacheVolume, repeated: true },
    { no: 6, name: "generations", kind: "message", T: CacheVolume, repeated: true },
    { no: 4, name: "created_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TagSummary {
    return new TagSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TagSummary {
    return new TagSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TagSummary {
    return new TagSummary().fromJsonString(jsonString, options);
  }

  static equals(a: TagSummary | PlainMessage<TagSummary> | undefined, b: TagSummary | PlainMessage<TagSummary> | undefined): boolean {
    return proto3.util.equals(TagSummary, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.DestroyCacheVolumeRequest
 */
export class DestroyCacheVolumeRequest extends Message<DestroyCacheVolumeRequest> {
  /**
   * Required input.
   *
   * @generated from field: string tag = 1;
   */
  tag = "";

  constructor(data?: PartialMessage<DestroyCacheVolumeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.DestroyCacheVolumeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DestroyCacheVolumeRequest {
    return new DestroyCacheVolumeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DestroyCacheVolumeRequest {
    return new DestroyCacheVolumeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DestroyCacheVolumeRequest {
    return new DestroyCacheVolumeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DestroyCacheVolumeRequest | PlainMessage<DestroyCacheVolumeRequest> | undefined, b: DestroyCacheVolumeRequest | PlainMessage<DestroyCacheVolumeRequest> | undefined): boolean {
    return proto3.util.equals(DestroyCacheVolumeRequest, a, b);
  }
}

/**
 * Cache metadata allows the user to teach Namespace about how a Cache Volume is used.
 * Namespace persists cache metadata and tracks cache utilization for each configured path.
 * To provide cache metadata to Namespace, produce a JSON file inside the Cache Volume
 * at the path `.ns/cache-metadata.json`.
 *
 * @generated from message namespace.cloud.compute.v1beta.CacheMetadata
 */
export class CacheMetadata extends Message<CacheMetadata> {
  /**
   * Version of the metadata spec. Currently, only version 1 is supported.
   *
   * @generated from field: uint32 version = 1;
   */
  version = 0;

  /**
   * The timestamp of when the cache metadata was last updated (in UTC).
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * A map of user-requested cache usages. The key is the path in the cache.
   *
   * @generated from field: map<string, namespace.cloud.compute.v1beta.CachePathUsage> user_request = 3;
   */
  userRequest: { [key: string]: CachePathUsage } = {};

  constructor(data?: PartialMessage<CacheMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CacheMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "updated_at", kind: "message", T: Timestamp },
    { no: 3, name: "user_request", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: CachePathUsage} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CacheMetadata {
    return new CacheMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CacheMetadata {
    return new CacheMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CacheMetadata {
    return new CacheMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: CacheMetadata | PlainMessage<CacheMetadata> | undefined, b: CacheMetadata | PlainMessage<CacheMetadata> | undefined): boolean {
    return proto3.util.equals(CacheMetadata, a, b);
  }
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CachePathUsage
 */
export class CachePathUsage extends Message<CachePathUsage> {
  /**
   * Name of the system that configured this cache path usage.
   *
   * @generated from field: string source = 1;
   */
  source = "";

  /**
   * What framework/purpose is this cache path used for?
   *
   * @generated from field: string cache_framework = 2;
   */
  cacheFramework = "";

  /**
   * A series of bind mounts that have been applied to this cache path.
   *
   * @generated from field: repeated string mount_target = 3;
   */
  mountTarget: string[] = [];

  constructor(data?: PartialMessage<CachePathUsage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CachePathUsage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cache_framework", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "mount_target", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CachePathUsage {
    return new CachePathUsage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CachePathUsage {
    return new CachePathUsage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CachePathUsage {
    return new CachePathUsage().fromJsonString(jsonString, options);
  }

  static equals(a: CachePathUsage | PlainMessage<CachePathUsage> | undefined, b: CachePathUsage | PlainMessage<CachePathUsage> | undefined): boolean {
    return proto3.util.equals(CachePathUsage, a, b);
  }
}

