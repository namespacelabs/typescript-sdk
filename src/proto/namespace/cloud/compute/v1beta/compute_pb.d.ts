// @generated by protoc-gen-es v1.3.0 with parameter "target=js+ts+dts"
// @generated from file proto/namespace/cloud/compute/v1beta/compute.proto (package namespace.cloud.compute.v1beta, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Label, LabelFilterEntry } from "../../../stdlib/labels_pb.js";
import type { HttpCallbackEndpoint } from "../../../stdlib/callback_pb.js";
import type { TimeSeries } from "../../../stdlib/timeseries_pb.js";
import type { StringMatcher } from "../../../stdlib/matchers_pb.js";

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest
 */
export declare class CreateInstanceRequest extends Message<CreateInstanceRequest> {
  /**
   * The shape of the instance to be created.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceShape shape = 1;
   */
  shape?: InstanceShape;

  /**
   * A list of features that should be enabled in this instance.
   * Deprecated: use feature_configuration below instead.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.Feature features = 3;
   */
  features: CreateInstanceRequest_Feature[];

  /**
   * A list of features that should be enabled in this instance.
   *
   * @generated from field: namespace.cloud.compute.v1beta.CreateInstanceRequest.FeatureConfiguration feature_configuration = 11;
   */
  featureConfiguration?: CreateInstanceRequest_FeatureConfiguration;

  /**
   * A human-facing description of the purpose of this instance. Used for
   * debugging purposes.
   *
   * @generated from field: string documented_purpose = 4;
   */
  documentedPurpose: string;

  /**
   * A set of labels that are attached to the new instance. Instances can be
   * queried based on labels, see also ListInstancesRequest.
   *
   * @generated from field: repeated namespace.stdlib.Label labels = 5;
   */
  labels: Label[];

  /**
   * Timestamp of when this instance should be released (in UTC). Requested
   * deadlines can be modified by policy. For example, if a workspace is
   * configured with a maximum deadline of 24h, and a instance is created with
   * a requested deadline of 48h, the resulting instance will have a deadline
   * of 24h.
   *
   * When a instance hits its deadline, processes within will receive a
   * `SIGTERM` and have a maximum time to shutdown gracefully before the
   * instance is destroyed.
   *
   * Note: In JSON format, the Timestamp type is encoded as a string in the
   * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
   *
   * @generated from field: google.protobuf.Timestamp deadline = 6;
   */
  deadline?: Timestamp;

  /**
   * Deprecated and ignored; it used to allow creation queueing.
   *
   * @generated from field: bool interactive = 7;
   */
  interactive: boolean;

  /**
   * Requests that the new instance be created in the specified region.
   *
   * Typically a region is not set. In that case, the Namespace platform makes
   * a placement a decision on behalf of users based on the type of workload,
   * tenant policies and available global capacity.
   *
   * @generated from field: string region = 8;
   */
  region: string;

  /**
   * Start the specified containers as part of instance creation. Containers
   * are deployed to `containerd` directly. See ContainerRequest for more
   * details. Only supported on Linux platform.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.ContainerRequest containers = 9;
   */
  containers: ContainerRequest[];

  /**
   * Start the specified applications on the instance without using
   * containerization. Only supported on macOS platform.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.ApplicationRequest applications = 14;
   */
  applications: ApplicationRequest[];

  /**
   * A set of experimental features that should be attached to this instance.
   * Experimental features may be removed or modified at any time by the
   * Namespace team.
   *
   * @generated from field: namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures experimental = 10;
   */
  experimental?: CreateInstanceRequest_ExperimentalFeatures;

  /**
   * Attach storage to the instance, notably, cache volumes.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.VolumeRequest volumes = 12;
   */
  volumes: VolumeRequest[];

  /**
   * Enable container caching. Container caching is only available on Linux.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerCache container_cache = 13;
   */
  containerCache?: ContainerCache;

  /**
   * We'll HTTP POST on this URL whenever the instance changes state. The body
   * of the post will be application/json with a serialized
   * InstanceEventMetadata.
   *
   * @generated from field: namespace.stdlib.HttpCallbackEndpoint http_event_callback = 15;
   */
  httpEventCallback?: HttpCallbackEndpoint;

  /**
   * Additional authenticated registries that can be targeted when pulling images.
   * The map key is the registry address.
   *
   * @generated from field: map<string, namespace.cloud.compute.v1beta.AdditionalRegistry> additional_registries = 16;
   */
  additionalRegistries: { [key: string]: AdditionalRegistry };

  constructor(data?: PartialMessage<CreateInstanceRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest;

  static equals(a: CreateInstanceRequest | PlainMessage<CreateInstanceRequest> | undefined, b: CreateInstanceRequest | PlainMessage<CreateInstanceRequest> | undefined): boolean;
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.CreateInstanceRequest.Feature
 */
export declare enum CreateInstanceRequest_Feature {
  /**
   * @generated from enum value: FEATURE_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Enable Kubernetes in this instance.
   *
   * @generated from enum value: FEATURE_KUBERNETES = 1;
   */
  KUBERNETES = 1,

  /**
   * Automatically expose ingresses annotated with "kubernetes.namespace.so/expose: true"
   * as authenticated HTTP endpoints.
   *
   * @generated from enum value: FEATURE_KUBERNETES_INGRESS_MANAGER = 2;
   */
  KUBERNETES_INGRESS_MANAGER = 2,
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures
 */
export declare class CreateInstanceRequest_ExperimentalFeatures extends Message<CreateInstanceRequest_ExperimentalFeatures> {
  /**
   * A list of private features used to enable experimental behavior in a
   * instance.
   *
   * For more details chat with the Namespace team.
   *
   * @generated from field: repeated string private_feature = 1;
   */
  privateFeature: string[];

  /**
   * Attach the specified disks as additional read-only volumes to the new
   * instance. Disks are specified as container image sources, which are
   * converted into a flattened filesystem that is then made available as
   * block storage that is attached to the VM that backs the instance.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Disk disks = 2;
   */
  disks: CreateInstanceRequest_ExperimentalFeatures_Disk[];

  /**
   * Configure `containerd` with an additional set of shims.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.ContainerdShim containerd_shims = 3;
   */
  containerdShims: CreateInstanceRequest_ExperimentalFeatures_ContainerdShim[];

  /**
   * Export a set of ports using a TLS frontend. Because TLS allows a
   * proxy to perform SNI-based routing, different services can be backed
   * by a single TLS ingress.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.TlsBackedPort tls_backed_ports = 4;
   */
  tlsBackedPorts: CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort[];

  /**
   * Request that the following set of container images be prewarmed in
   * `containerd`. This is strictly best-effort.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.PrewarmContainerImage prewarm_container_images = 5;
   */
  prewarmContainerImages: CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage[];

  /**
   * Return an equivalent workload identity token that identifies the
   * workload just created.
   *
   * @generated from field: bool return_workload_identity_token = 6;
   */
  returnWorkloadIdentityToken: boolean;

  /**
   * Register a wildcard domain for ingress directed at this new instance.
   *
   * @generated from field: bool enable_wildcard_domain = 7;
   */
  enableWildcardDomain: boolean;

  /**
   * Reach out to the Namespace team to learn more about this capability.
   * A union of these set of volumes and the volumes defined in
   * CreateInstanceRequest are used.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.VolumeRequest volumes = 8;
   */
  volumes: VolumeRequest[];

  /**
   * Reach out to the Namespace team to learn more about this capability.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.DirectoryRequest ensure_directory = 9;
   */
  ensureDirectory: CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest[];

  /**
   * Reach out to the Namespace team to learn more about this capability.
   *
   * @generated from field: string unique_tag = 10;
   */
  uniqueTag: string;

  /**
   * Reach out to the Namespace team to learn more about this capability.
   *
   * @generated from field: map<string, string> exported_unix_sockets = 11;
   */
  exportedUnixSockets: { [key: string]: string };

  /**
   * Enable container caching.
   *
   * @generated from field: namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.ContainerCache container_cache = 12;
   */
  containerCache?: CreateInstanceRequest_ExperimentalFeatures_ContainerCache;

  /**
   * Hooks to trigger before any programs (containers or applications) are started.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook pre_start_hook = 17;
   */
  preStartHook: CreateInstanceRequest_ExperimentalFeatures_Hook[];

  /**
   * Hooks to trigger before the instance shuts down.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook pre_shutdown_hook = 13;
   */
  preShutdownHook: CreateInstanceRequest_ExperimentalFeatures_Hook[];

  /**
   * Public keys to enroll for SSH access to the created instance.
   *
   * @generated from field: repeated string authorized_ssh_keys = 14;
   */
  authorizedSshKeys: string[];

  /**
   * Base image ID to use for a macOS instance.
   *
   * @generated from field: string macos_base_image_id = 16;
   */
  macosBaseImageId: string;

  /**
   * Reach out to the Namespace team to learn more about this capability.
   *
   * @generated from field: map<string, string> internal = 15;
   */
  internal: { [key: string]: string };

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures;

  static equals(a: CreateInstanceRequest_ExperimentalFeatures | PlainMessage<CreateInstanceRequest_ExperimentalFeatures> | undefined, b: CreateInstanceRequest_ExperimentalFeatures | PlainMessage<CreateInstanceRequest_ExperimentalFeatures> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Disk
 */
export declare class CreateInstanceRequest_ExperimentalFeatures_Disk extends Message<CreateInstanceRequest_ExperimentalFeatures_Disk> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string image_ref = 2;
   */
  imageRef: string;

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_Disk>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Disk";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Disk;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Disk;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Disk;

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_Disk | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_Disk> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_Disk | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_Disk> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.ContainerdShim
 */
export declare class CreateInstanceRequest_ExperimentalFeatures_ContainerdShim extends Message<CreateInstanceRequest_ExperimentalFeatures_ContainerdShim> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string runtime_type = 2;
   */
  runtimeType: string;

  /**
   * @generated from field: repeated string add_to_path = 3;
   */
  addToPath: string[];

  /**
   * @generated from field: string binary_name = 4;
   */
  binaryName: string;

  /**
   * @generated from field: string root = 5;
   */
  root: string;

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_ContainerdShim>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.ContainerdShim";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_ContainerdShim;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_ContainerdShim;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_ContainerdShim;

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_ContainerdShim | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_ContainerdShim> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_ContainerdShim | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_ContainerdShim> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.TlsBackedPort
 */
export declare class CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort extends Message<CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: int32 port = 2;
   */
  port: number;

  /**
   * If this is false, TLS is used in passthrough mode.
   *
   * @generated from field: bool terminate_tls = 3;
   */
  terminateTls: boolean;

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.TlsBackedPort";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort;

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_TlsBackedPort> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.PrewarmContainerImage
 */
export declare class CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage extends Message<CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage> {
  /**
   * The target containerd that the image should be warmed up to. Use
   * "default" for containers started by Namespace; "moby" for Docker
   * containers and "k8s" for Kubernetes.
   *
   * @generated from field: string containerd_namespace = 1;
   */
  containerdNamespace: string;

  /**
   * A fully qualified image reference, including digest. Only fully
   * specified images will be part of optimized profiles. Non-fully
   * qualified references are silently dropped.
   *
   * @generated from field: string image_ref = 2;
   */
  imageRef: string;

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.PrewarmContainerImage";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage;

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_PrewarmContainerImage> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.DirectoryRequest
 */
export declare class CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest extends Message<CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest> {
  /**
   * @generated from field: string abs_path = 1;
   */
  absPath: string;

  /**
   * @generated from field: uint32 mode = 2;
   */
  mode: number;

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.DirectoryRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest;

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_DirectoryRequest> | undefined): boolean;
}

/**
 * Deprecated: use the top-most message.
 *
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.ContainerCache
 */
export declare class CreateInstanceRequest_ExperimentalFeatures_ContainerCache extends Message<CreateInstanceRequest_ExperimentalFeatures_ContainerCache> {
  /**
   * Which cache volume to use to store container images.
   *
   * @generated from field: string cache_volume_tag = 1;
   */
  cacheVolumeTag: string;

  /**
   * If this is a separate volume, the size of the volume is required. Must not be set if this is an existing tag.
   *
   * @generated from field: int64 size_mb = 2;
   */
  sizeMb: bigint;

  /**
   * If this is an existing volume (i.e. for which a volume request exists), the relative path within that volume to use. Optional.
   *
   * @generated from field: string relative_path = 3;
   */
  relativePath: string;

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_ContainerCache>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.ContainerCache";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_ContainerCache;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_ContainerCache;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_ContainerCache;

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_ContainerCache | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_ContainerCache> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_ContainerCache | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_ContainerCache> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook
 */
export declare class CreateInstanceRequest_ExperimentalFeatures_Hook extends Message<CreateInstanceRequest_ExperimentalFeatures_Hook> {
  /**
   * If set, execute this command during the hook.
   *
   * @generated from field: namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook.Command command = 1;
   */
  command?: CreateInstanceRequest_ExperimentalFeatures_Hook_Command;

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_Hook>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Hook;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Hook;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Hook;

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_Hook | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_Hook> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_Hook | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_Hook> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook.Command
 */
export declare class CreateInstanceRequest_ExperimentalFeatures_Hook_Command extends Message<CreateInstanceRequest_ExperimentalFeatures_Hook_Command> {
  /**
   * @generated from field: string command = 1;
   */
  command: string;

  /**
   * A set of arguments to pass to the command invocation.
   *
   * Example: `["--foobar"]`
   *
   * @generated from field: repeated string args = 2;
   */
  args: string[];

  /**
   * A set of environment values to be used as the command's environment.
   *
   * These set of environment variables are added in addition to a
   * system-specified set of environment variables.
   *
   * Example: `{"FOOBAR": "1"}`
   *
   * @generated from field: map<string, string> environment = 3;
   */
  environment: { [key: string]: string };

  constructor(data?: PartialMessage<CreateInstanceRequest_ExperimentalFeatures_Hook_Command>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.ExperimentalFeatures.Hook.Command";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Hook_Command;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Hook_Command;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_ExperimentalFeatures_Hook_Command;

  static equals(a: CreateInstanceRequest_ExperimentalFeatures_Hook_Command | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_Hook_Command> | undefined, b: CreateInstanceRequest_ExperimentalFeatures_Hook_Command | PlainMessage<CreateInstanceRequest_ExperimentalFeatures_Hook_Command> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateInstanceRequest.FeatureConfiguration
 */
export declare class CreateInstanceRequest_FeatureConfiguration extends Message<CreateInstanceRequest_FeatureConfiguration> {
  /**
   * If set, also runs a single-node Kubernetes in this instance. Must be
   * set to a specific Kubernetes major+minor version, e.g. "1.26" or "1.28".
   *
   * @generated from field: string enable_kubernetes_version = 1;
   */
  enableKubernetesVersion: string;

  /**
   * Automatically expose ingresses annotated with "kubernetes.namespace.so/expose: true"
   * as authenticated HTTP endpoints.
   *
   * @generated from field: bool enable_kubernetes_ingress_manager = 2;
   */
  enableKubernetesIngressManager: boolean;

  constructor(data?: PartialMessage<CreateInstanceRequest_FeatureConfiguration>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateInstanceRequest.FeatureConfiguration";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInstanceRequest_FeatureConfiguration;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInstanceRequest_FeatureConfiguration;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInstanceRequest_FeatureConfiguration;

  static equals(a: CreateInstanceRequest_FeatureConfiguration | PlainMessage<CreateInstanceRequest_FeatureConfiguration> | undefined, b: CreateInstanceRequest_FeatureConfiguration | PlainMessage<CreateInstanceRequest_FeatureConfiguration> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AdditionalRegistry
 */
export declare class AdditionalRegistry extends Message<AdditionalRegistry> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator authentication = 1;
   */
  authentication?: AdditionalRegistry_Authenticator;

  constructor(data?: PartialMessage<AdditionalRegistry>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AdditionalRegistry";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdditionalRegistry;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdditionalRegistry;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdditionalRegistry;

  static equals(a: AdditionalRegistry | PlainMessage<AdditionalRegistry> | undefined, b: AdditionalRegistry | PlainMessage<AdditionalRegistry> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator
 */
export declare class AdditionalRegistry_Authenticator extends Message<AdditionalRegistry_Authenticator> {
  /**
   * A pair of username and password to use when pulling images.
   *
   * @generated from field: namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.Basic basic = 1;
   */
  basic?: AdditionalRegistry_Authenticator_Basic;

  /**
   * Instruct Namespace to generate an OIDC token to access the registry.
   * The generated access token will be signed by the issuer `https://federation.namespaceapis.com`.
   *
   * @generated from field: namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.OpenIDFederation openid = 2;
   */
  openid?: AdditionalRegistry_Authenticator_OpenIDFederation;

  /**
   * Namespace will federate with AWS to obtain an [ECR authorization token](https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_GetAuthorizationToken.html).
   * Make sure to grant the required `ecr:*` permissions to the federated IAM role.
   *
   * @generated from field: namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.AssumeRoleFromAwsFederation ecr_token_from_aws_federation = 3;
   */
  ecrTokenFromAwsFederation?: AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation;

  constructor(data?: PartialMessage<AdditionalRegistry_Authenticator>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdditionalRegistry_Authenticator;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator;

  static equals(a: AdditionalRegistry_Authenticator | PlainMessage<AdditionalRegistry_Authenticator> | undefined, b: AdditionalRegistry_Authenticator | PlainMessage<AdditionalRegistry_Authenticator> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.Basic
 */
export declare class AdditionalRegistry_Authenticator_Basic extends Message<AdditionalRegistry_Authenticator_Basic> {
  /**
   * @generated from field: string username = 1;
   */
  username: string;

  /**
   * @generated from field: string password_secret_ref = 2;
   */
  passwordSecretRef: string;

  constructor(data?: PartialMessage<AdditionalRegistry_Authenticator_Basic>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.Basic";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdditionalRegistry_Authenticator_Basic;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator_Basic;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator_Basic;

  static equals(a: AdditionalRegistry_Authenticator_Basic | PlainMessage<AdditionalRegistry_Authenticator_Basic> | undefined, b: AdditionalRegistry_Authenticator_Basic | PlainMessage<AdditionalRegistry_Authenticator_Basic> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.OpenIDFederation
 */
export declare class AdditionalRegistry_Authenticator_OpenIDFederation extends Message<AdditionalRegistry_Authenticator_OpenIDFederation> {
  /**
   * Required.
   *
   * @generated from field: string username = 1;
   */
  username: string;

  /**
   * Optional. If not set, the audience will be the address of the target registry.
   *
   * @generated from field: string audience = 2;
   */
  audience: string;

  constructor(data?: PartialMessage<AdditionalRegistry_Authenticator_OpenIDFederation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.OpenIDFederation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdditionalRegistry_Authenticator_OpenIDFederation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator_OpenIDFederation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator_OpenIDFederation;

  static equals(a: AdditionalRegistry_Authenticator_OpenIDFederation | PlainMessage<AdditionalRegistry_Authenticator_OpenIDFederation> | undefined, b: AdditionalRegistry_Authenticator_OpenIDFederation | PlainMessage<AdditionalRegistry_Authenticator_OpenIDFederation> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.AssumeRoleFromAwsFederation
 */
export declare class AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation extends Message<AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation> {
  /**
   * Amazon Resource Name of the IAM role to assume.
   * The IAM role must be [set up for federated access from Namespace](https://namespace.so/docs/federation/aws#accessing-aws-resources-from-namespace) including an appropriate trust policy.
   *
   * @generated from field: string role_arn = 1;
   */
  roleArn: string;

  constructor(data?: PartialMessage<AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AdditionalRegistry.Authenticator.AssumeRoleFromAwsFederation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation;

  static equals(a: AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation | PlainMessage<AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation> | undefined, b: AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation | PlainMessage<AdditionalRegistry_Authenticator_AssumeRoleFromAwsFederation> | undefined): boolean;
}

/**
 * DescribeInstanceResponse is returned as a result to CreateInstance or
 * DescribeInstance. It includes both standard metadata (that focuses on
 * instance status), and extended metadata (credentials, endpoints, etc).
 *
 * @generated from message namespace.cloud.compute.v1beta.DescribeInstanceResponse
 */
export declare class DescribeInstanceResponse extends Message<DescribeInstanceResponse> {
  /**
   * A fully qualified URL that points to the instance summary in the
   * dashboard. E.g.
   * `https://cloud.namespace.so/01gr490qvbntkjn9jwypnd4g04/instance/ui3e3e3g7cfrg`.
   *
   * @generated from field: string instance_url = 1;
   */
  instanceUrl: string;

  /**
   * InstanceMetadata include both creation time specified fields such as
   * labels, and status-like properties like the destroyed timestamp if the
   * instance is no longer running.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata metadata = 2;
   */
  metadata?: InstanceMetadata;

  /**
   * Service-specific metadata which may include credentials. E.g. SSH or
   * Kubernetes endpoint information.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceExtendedMetadata extended_metadata = 3;
   */
  extendedMetadata?: InstanceExtendedMetadata;

  /**
   * Endpoint information of the private Container Registry that is usable
   * with this instance. Instances are pre-configured to access workspace-owned
   * images in this registry.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ImageRegistry registry = 4;
   */
  registry?: ImageRegistry;

  /**
   * If the instance creation specified a set of containers, specifies the
   * corresponding allocated containers.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.AllocatedContainer containers = 5;
   */
  containers: AllocatedContainer[];

  /**
   * A set of experimental features attached to this instance. Experimental
   * features may be removed or modified at any time by the Namespace team.
   *
   * @generated from field: namespace.cloud.compute.v1beta.DescribeInstanceResponse.ExperimentalFeatures experimental = 6;
   */
  experimental?: DescribeInstanceResponse_ExperimentalFeatures;

  /**
   * A list of metadata that is attached to the instance.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.Attachment attachments = 7;
   */
  attachments: Attachment[];

  /**
   * The instance's container cache configuration, if one exists.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerCache container_cache = 8;
   */
  containerCache?: ContainerCache;

  constructor(data?: PartialMessage<DescribeInstanceResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.DescribeInstanceResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeInstanceResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeInstanceResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeInstanceResponse;

  static equals(a: DescribeInstanceResponse | PlainMessage<DescribeInstanceResponse> | undefined, b: DescribeInstanceResponse | PlainMessage<DescribeInstanceResponse> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.DescribeInstanceResponse.ExperimentalFeatures
 */
export declare class DescribeInstanceResponse_ExperimentalFeatures extends Message<DescribeInstanceResponse_ExperimentalFeatures> {
  /**
   * If a workload identity token was requested at creation time, it's
   * returned exclusively as part of the response to CreateInstance().
   *
   * @generated from field: string workload_identity_token = 1;
   */
  workloadIdentityToken: string;

  /**
   * If `enable_wildcard_certificate` is set, the certificate that is
   * being generated for this instance. E.g. `*.{instanceid}.foobar.com`.
   *
   * @generated from field: string instance_wildcard_domain = 2;
   */
  instanceWildcardDomain: string;

  constructor(data?: PartialMessage<DescribeInstanceResponse_ExperimentalFeatures>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.DescribeInstanceResponse.ExperimentalFeatures";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeInstanceResponse_ExperimentalFeatures;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeInstanceResponse_ExperimentalFeatures;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeInstanceResponse_ExperimentalFeatures;

  static equals(a: DescribeInstanceResponse_ExperimentalFeatures | PlainMessage<DescribeInstanceResponse_ExperimentalFeatures> | undefined, b: DescribeInstanceResponse_ExperimentalFeatures | PlainMessage<DescribeInstanceResponse_ExperimentalFeatures> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerCache
 */
export declare class ContainerCache extends Message<ContainerCache> {
  /**
   * Which cache volume to use to store container images.
   *
   * @generated from field: string cache_volume_tag = 1;
   */
  cacheVolumeTag: string;

  /**
   * If this is a separate volume, the size of the volume is required. Must not be set if this is an existing tag.
   *
   * @generated from field: int64 size_mb = 2;
   */
  sizeMb: bigint;

  /**
   * If this is an existing volume (i.e. for which a volume request exists), the relative path within that volume to use. Optional.
   *
   * @generated from field: string relative_path = 3;
   */
  relativePath: string;

  constructor(data?: PartialMessage<ContainerCache>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerCache";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerCache;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerCache;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerCache;

  static equals(a: ContainerCache | PlainMessage<ContainerCache> | undefined, b: ContainerCache | PlainMessage<ContainerCache> | undefined): boolean;
}

/**
 * A typed blob that can be attached to an instance.
 *
 * @generated from message namespace.cloud.compute.v1beta.Attachment
 */
export declare class Attachment extends Message<Attachment> {
  /**
   * @generated from field: string type_url = 1;
   */
  typeUrl: string;

  /**
   * @generated from field: bytes content = 2;
   */
  content: Uint8Array;

  constructor(data?: PartialMessage<Attachment>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.Attachment";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Attachment;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Attachment;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Attachment;

  static equals(a: Attachment | PlainMessage<Attachment> | undefined, b: Attachment | PlainMessage<Attachment> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.StartContainersRequest
 */
export declare class StartContainersRequest extends Message<StartContainersRequest> {
  /**
   * The ID of instance which this call targets.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  /**
   * The set of additional containers that should be started in the target
   * instance.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.ContainerRequest containers = 2;
   */
  containers: ContainerRequest[];

  constructor(data?: PartialMessage<StartContainersRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.StartContainersRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartContainersRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartContainersRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartContainersRequest;

  static equals(a: StartContainersRequest | PlainMessage<StartContainersRequest> | undefined, b: StartContainersRequest | PlainMessage<StartContainersRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerRequest
 */
export declare class ContainerRequest extends Message<ContainerRequest> {
  /**
   * A name of the container being created. Must be unique.
   *
   * TODO: document valid regular expression.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * An image reference to the container image used to back this container.
   *
   * Ideally image references that are specified are fully resolved and
   * "pinned", i.e. their digest is also specified.
   *
   * If no resolved image is provided, it is resolved during creation time,
   * which may add latency to the creation request.
   *
   * Example:
   * `ubuntu:22.04@sha256:dfd64a3b4296d8c9b62aa3309984f8620b98d87e47492599ee20739e8eb54fbf`
   *
   * @generated from field: string image_ref = 2;
   */
  imageRef: string;

  /**
   * A set of arguments to pass to the container.
   *
   * TODO document relationship with entrypoint.
   *
   * Example: `["--foobar"]`
   *
   * @generated from field: repeated string args = 3;
   */
  args: string[];

  /**
   * A set of environment values to be used as the container's environment.
   *
   * These set of environment variables are added in addition to a
   * system-specified set of environment variables.
   *
   * Example: `{"FOOBAR": "1"}`
   *
   * This API will always be supported, but you may want to consider
   * `env_vars` instead as a more complete API.
   *
   * @generated from field: map<string, string> environment = 4;
   */
  environment: { [key: string]: string };

  /**
   * A set of environment values to be used as the container's environment.
   *
   * These set of environment variables are added in addition to a
   * system-specified set of environment variables.
   *
   * Example: `{"FOOBAR": "1"}`
   *
   * Can also refer to different source values, e.g. secrets.
   * By default, no secrets are injected.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.EnvironmentVariable env_vars = 14;
   */
  envVars: EnvironmentVariable[];

  /**
   * If set, makes docker available to the container. Any containers that are
   * started by the container via the Docker API are then run as containers
   * alongside this container, not as children.
   *
   * Bind mounts work across containers by using container-aware bind mount
   * resolution.
   *
   * Example: `/var/run/docker.sock`
   *
   * @generated from field: string docker_sock_path = 5;
   */
  dockerSockPath: string;

  /**
   * If set, injects Namespace metadata and credentials to the container (e.g.
   * the workload token).
   *
   * Can be used to allow the container to call Namespace APIs as the
   * instance.
   *
   * Example: `/var/run/nsc`
   *
   * If set, mounts the nsc token (and state) in the container.
   *
   * @generated from field: string nsc_state_path = 6;
   */
  nscStatePath: string;

  /**
   * A set of container ports to make available through the public ingress.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.ContainerPort export_ports = 7;
   */
  exportPorts: ContainerPort[];

  /**
   * By default containers run in a bridge network, with NAT. This allows
   * containers to listen on arbitrary ports without requiring coordination.
   *
   * The container can be run in the instance networking by specifying `HOST`.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerRequest.Network network = 9;
   */
  network: ContainerRequest_Network;

  /**
   * A list of experimental features to enable in this container.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures experimental = 10;
   */
  experimental?: ContainerRequest_ExperimentalFeatures;

  /**
   * Run the container with all capabilities.
   *
   * @generated from field: bool privileged = 11;
   */
  privileged: boolean;

  /**
   * A set of volumes to be attached to this container.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.VolumeRequest volumes = 12;
   */
  volumes: VolumeRequest[];

  /**
   * When a container terminates, the instance where it runs in will also
   * terminate. If the workload type is set to `service`, the instance will always be
   * marked as failed, regardless of the exit code of the container.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerRequest.WorkloadType workload_type = 13;
   */
  workloadType: ContainerRequest_WorkloadType;

  constructor(data?: PartialMessage<ContainerRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerRequest;

  static equals(a: ContainerRequest | PlainMessage<ContainerRequest> | undefined, b: ContainerRequest | PlainMessage<ContainerRequest> | undefined): boolean;
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.ContainerRequest.Network
 */
export declare enum ContainerRequest_Network {
  /**
   * @generated from enum value: NETWORK_UNKNOWN = 0;
   */
  NETWORK_UNKNOWN = 0,

  /**
   * Default
   *
   * @generated from enum value: BRIDGE = 1;
   */
  BRIDGE = 1,

  /**
   * @generated from enum value: HOST = 2;
   */
  HOST = 2,
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.ContainerRequest.WorkloadType
 */
export declare enum ContainerRequest_WorkloadType {
  /**
   * Defaults to JOB.
   *
   * @generated from enum value: WORKLOAD_TYPE_UNKNOWN = 0;
   */
  WORKLOAD_TYPE_UNKNOWN = 0,

  /**
   * Default; when a container terminates, the instance also terminates.
   *
   * @generated from enum value: JOB = 1;
   */
  JOB = 1,

  /**
   * The container is marked as critical, and if the container fails, the instance will fail with a fatal error.
   *
   * @generated from enum value: SERVICE = 2;
   */
  SERVICE = 2,
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures
 */
export declare class ContainerRequest_ExperimentalFeatures extends Message<ContainerRequest_ExperimentalFeatures> {
  /**
   * Array of log file patterns to retain. Globbing is supported.
   *
   * @generated from field: repeated string include_logs = 1;
   */
  includeLogs: string[];

  /**
   * A series of bind mounts to apply to the container. Can be used for
   * cross-container communication.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.HostMount host_mount = 2;
   */
  hostMount: ContainerRequest_ExperimentalFeatures_HostMount[];

  /**
   * Run the container with all capabilities.
   * Deprecated: use privileged under the ContainerRequest.
   *
   * @generated from field: bool privileged = 3;
   */
  privileged: boolean;

  /**
   * Reach out to the Namespace team to learn more about this capability.
   *
   * @generated from field: map<string, string> exported_unix_sockets = 4;
   */
  exportedUnixSockets: { [key: string]: string };

  /**
   * Additional credentials that can be used to pull the image used to back this container.
   *
   * Prefer using `CreateInstanceRequest.additional_registries` to provide persistent pull credentials for the instance.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.ImagePullCredentials image_pull_credentials = 5;
   */
  imagePullCredentials?: ContainerRequest_ExperimentalFeatures_ImagePullCredentials;

  /**
   * Store the contents of the run (and only the contents of the ephemeral
   * disk) as a new container image. Can only push to `nscr.io`.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.PushEphemeralDiskAsImage push_ephemeral_disk_as_image = 6;
   */
  pushEphemeralDiskAsImage?: ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage;

  /**
   * Set of capabilities to add to the container, e.g. NET_CAP.
   *
   * @generated from field: repeated string cap_add = 7;
   */
  capAdd: string[];

  /**
   * Set of capabilities to drop.
   *
   * @generated from field: repeated string cap_drop = 8;
   */
  capDrop: string[];

  /**
   * Set of devices to expose to the container.
   *
   * @generated from field: repeated string devices = 9;
   */
  devices: string[];

  /**
   * A set of volumes that get mounted into arbitrary paths within the
   * container namespace. Always read only.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.SidecarVolume sidecar_volumes = 10;
   */
  sidecarVolumes: ContainerRequest_ExperimentalFeatures_SidecarVolume[];

  /**
   * Chat with support@namespace.so about this setting.
   *
   * @generated from field: bool incremental_loading = 11;
   */
  incrementalLoading: boolean;

  /**
   * Chat with support@namespace.so about this setting.
   *
   * @generated from field: bool sandbox_like = 12;
   */
  sandboxLike: boolean;

  constructor(data?: PartialMessage<ContainerRequest_ExperimentalFeatures>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerRequest_ExperimentalFeatures;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures;

  static equals(a: ContainerRequest_ExperimentalFeatures | PlainMessage<ContainerRequest_ExperimentalFeatures> | undefined, b: ContainerRequest_ExperimentalFeatures | PlainMessage<ContainerRequest_ExperimentalFeatures> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.HostMount
 */
export declare class ContainerRequest_ExperimentalFeatures_HostMount extends Message<ContainerRequest_ExperimentalFeatures_HostMount> {
  /**
   * @generated from field: string host_path = 1;
   */
  hostPath: string;

  /**
   * @generated from field: string container_path = 2;
   */
  containerPath: string;

  /**
   * @generated from field: bool readonly = 3;
   */
  readonly: boolean;

  constructor(data?: PartialMessage<ContainerRequest_ExperimentalFeatures_HostMount>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.HostMount";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerRequest_ExperimentalFeatures_HostMount;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_HostMount;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_HostMount;

  static equals(a: ContainerRequest_ExperimentalFeatures_HostMount | PlainMessage<ContainerRequest_ExperimentalFeatures_HostMount> | undefined, b: ContainerRequest_ExperimentalFeatures_HostMount | PlainMessage<ContainerRequest_ExperimentalFeatures_HostMount> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.ImagePullCredentials
 */
export declare class ContainerRequest_ExperimentalFeatures_ImagePullCredentials extends Message<ContainerRequest_ExperimentalFeatures_ImagePullCredentials> {
  /**
   * Namespace will federate with AWS to obtain an [ECR authorization token](https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_GetAuthorizationToken.html).
   * Make sure to grant the required `ecr:*` permissions to the federated IAM role.
   *
   * @generated from field: namespace.cloud.compute.v1beta.AWSCredentials aws_ecr = 1;
   */
  awsEcr?: AWSCredentials;

  constructor(data?: PartialMessage<ContainerRequest_ExperimentalFeatures_ImagePullCredentials>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.ImagePullCredentials";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerRequest_ExperimentalFeatures_ImagePullCredentials;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_ImagePullCredentials;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_ImagePullCredentials;

  static equals(a: ContainerRequest_ExperimentalFeatures_ImagePullCredentials | PlainMessage<ContainerRequest_ExperimentalFeatures_ImagePullCredentials> | undefined, b: ContainerRequest_ExperimentalFeatures_ImagePullCredentials | PlainMessage<ContainerRequest_ExperimentalFeatures_ImagePullCredentials> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.PushEphemeralDiskAsImage
 */
export declare class ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage extends Message<ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage> {
  /**
   * E.g. nscr.io/foobar/myimage
   *
   * @generated from field: string target_image_ref = 1;
   */
  targetImageRef: string;

  constructor(data?: PartialMessage<ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.PushEphemeralDiskAsImage";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage;

  static equals(a: ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage | PlainMessage<ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage> | undefined, b: ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage | PlainMessage<ContainerRequest_ExperimentalFeatures_PushEphemeralDiskAsImage> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.SidecarVolume
 */
export declare class ContainerRequest_ExperimentalFeatures_SidecarVolume extends Message<ContainerRequest_ExperimentalFeatures_SidecarVolume> {
  /**
   * Optional.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string image_ref = 2;
   */
  imageRef: string;

  /**
   * @generated from field: string container_path = 3;
   */
  containerPath: string;

  constructor(data?: PartialMessage<ContainerRequest_ExperimentalFeatures_SidecarVolume>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerRequest.ExperimentalFeatures.SidecarVolume";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerRequest_ExperimentalFeatures_SidecarVolume;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_SidecarVolume;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerRequest_ExperimentalFeatures_SidecarVolume;

  static equals(a: ContainerRequest_ExperimentalFeatures_SidecarVolume | PlainMessage<ContainerRequest_ExperimentalFeatures_SidecarVolume> | undefined, b: ContainerRequest_ExperimentalFeatures_SidecarVolume | PlainMessage<ContainerRequest_ExperimentalFeatures_SidecarVolume> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.EnvironmentVariable
 */
export declare class EnvironmentVariable extends Message<EnvironmentVariable> {
  /**
   * Required: Name under which the environment variable will be available, e.g. "FOOBAR_VAR_NAME".
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional: If set, use this static value for the environment variable.
   *
   * @generated from field: string value = 2;
   */
  value: string;

  /**
   * Optional: If set, overrides value. Namespace will dynamically resolve the secret on instance creation.
   * By default, no secrets are resolved unless requested explicitly.
   *
   * @generated from field: string from_secret_id = 3;
   */
  fromSecretId: string;

  constructor(data?: PartialMessage<EnvironmentVariable>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.EnvironmentVariable";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnvironmentVariable;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnvironmentVariable;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnvironmentVariable;

  static equals(a: EnvironmentVariable | PlainMessage<EnvironmentVariable> | undefined, b: EnvironmentVariable | PlainMessage<EnvironmentVariable> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AWSCredentials
 */
export declare class AWSCredentials extends Message<AWSCredentials> {
  /**
   * Amazon Resource Name of the IAM role to assume.
   * The IAM role must be [set up for federated access from Namespace](https://namespace.so/docs/federation/aws#accessing-aws-resources-from-namespace) including an appropriate trust policy.
   *
   * @generated from field: string assume_role_arn = 1;
   */
  assumeRoleArn: string;

  constructor(data?: PartialMessage<AWSCredentials>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AWSCredentials";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSCredentials;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSCredentials;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSCredentials;

  static equals(a: AWSCredentials | PlainMessage<AWSCredentials> | undefined, b: AWSCredentials | PlainMessage<AWSCredentials> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.StartContainersResponse
 */
export declare class StartContainersResponse extends Message<StartContainersResponse> {
  /**
   * The corresponding set of allocated containers. Containers are returned in
   * the same order they are requested.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.AllocatedContainer containers = 1;
   */
  containers: AllocatedContainer[];

  constructor(data?: PartialMessage<StartContainersResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.StartContainersResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartContainersResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartContainersResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartContainersResponse;

  static equals(a: StartContainersResponse | PlainMessage<StartContainersResponse> | undefined, b: StartContainersResponse | PlainMessage<StartContainersResponse> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ApplicationRequest
 */
export declare class ApplicationRequest extends Message<ApplicationRequest> {
  /**
   * A name of the application being created. Must be unique.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional image with application distribution to be mounted on the instance.
   *
   * Note that ENTRYPOINT/CMD specified in the image config are not respected.
   *
   * Example: `nscr.io/abc012abc012/foobar`
   *
   * @generated from field: string image_ref = 2;
   */
  imageRef: string;

  /**
   * Command to execute.
   *
   * May be:
   *
   * * Absolute (refers to a pre-installed binary in the base image).
   *   Example: `/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild`.
   *
   * * Relative to the image specified above.
   *   Example: `./postgres`.
   *
   * * Resolved from $PATH (using the default $PATH of the base image)
   *   Example: `xcrun`.
   *
   * @generated from field: string command = 14;
   */
  command: string;

  /**
   * A set of arguments to pass to the application.
   *
   * Example: `["--foobar"]`
   *
   * @generated from field: repeated string args = 3;
   */
  args: string[];

  /**
   * A set of environment values to be used as the container's environment.
   *
   * These set of environment variables are added in addition to a
   * system-specified set of environment variables.
   *
   * Example: `{"FOOBAR": "1"}`
   * This API will always be supported, but you may want to consider
   * `env_vars` instead as a more complete API.
   *
   * @generated from field: map<string, string> environment = 4;
   */
  environment: { [key: string]: string };

  /**
   * A set of environment values to be used as the container's environment.
   *
   * These set of environment variables are added in addition to a
   * system-specified set of environment variables.
   *
   * Example: `{"FOOBAR": "1"}`
   *
   * Can also refer to different source values, e.g. secrets.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.EnvironmentVariable env_vars = 15;
   */
  envVars: EnvironmentVariable[];

  /**
   * When a container terminates, the instance where it runs in will also
   * terminate. If the workload type is set to `service`, the instance will always be
   * marked as failed, regardless of the exit code of the container.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ApplicationRequest.WorkloadType workload_type = 13;
   */
  workloadType: ApplicationRequest_WorkloadType;

  /**
   * A list of experimental features to enable in this container.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ApplicationRequest.ExperimentalFeatures experimental = 10;
   */
  experimental?: ApplicationRequest_ExperimentalFeatures;

  constructor(data?: PartialMessage<ApplicationRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ApplicationRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApplicationRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApplicationRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApplicationRequest;

  static equals(a: ApplicationRequest | PlainMessage<ApplicationRequest> | undefined, b: ApplicationRequest | PlainMessage<ApplicationRequest> | undefined): boolean;
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.ApplicationRequest.WorkloadType
 */
export declare enum ApplicationRequest_WorkloadType {
  /**
   * Defaults to JOB.
   *
   * @generated from enum value: WORKLOAD_TYPE_UNKNOWN = 0;
   */
  WORKLOAD_TYPE_UNKNOWN = 0,

  /**
   * Default; when the application terminates, the instance also terminates.
   *
   * @generated from enum value: JOB = 1;
   */
  JOB = 1,
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ApplicationRequest.ExperimentalFeatures
 */
export declare class ApplicationRequest_ExperimentalFeatures extends Message<ApplicationRequest_ExperimentalFeatures> {
  /**
   * Array of log file patterns to retain. Globbing is supported.
   *
   * @generated from field: repeated string include_logs = 1;
   */
  includeLogs: string[];

  constructor(data?: PartialMessage<ApplicationRequest_ExperimentalFeatures>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ApplicationRequest.ExperimentalFeatures";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApplicationRequest_ExperimentalFeatures;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApplicationRequest_ExperimentalFeatures;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApplicationRequest_ExperimentalFeatures;

  static equals(a: ApplicationRequest_ExperimentalFeatures | PlainMessage<ApplicationRequest_ExperimentalFeatures> | undefined, b: ApplicationRequest_ExperimentalFeatures | PlainMessage<ApplicationRequest_ExperimentalFeatures> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.DescribeInstanceRequest
 */
export declare class DescribeInstanceRequest extends Message<DescribeInstanceRequest> {
  /**
   * The ID of instance which this call targets.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  constructor(data?: PartialMessage<DescribeInstanceRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.DescribeInstanceRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeInstanceRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeInstanceRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeInstanceRequest;

  static equals(a: DescribeInstanceRequest | PlainMessage<DescribeInstanceRequest> | undefined, b: DescribeInstanceRequest | PlainMessage<DescribeInstanceRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.WaitInstanceRequest
 */
export declare class WaitInstanceRequest extends Message<WaitInstanceRequest> {
  /**
   * The ID of instance which this call targets.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  /**
   * If set to true, we don't fail the request if the instance is destroyed while waiting.
   *
   * @generated from field: bool destroyed_ok = 2;
   */
  destroyedOk: boolean;

  /**
   * The ID of the container to wait for.
   *
   * @generated from field: string container_id = 3;
   */
  containerId: string;

  constructor(data?: PartialMessage<WaitInstanceRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.WaitInstanceRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WaitInstanceRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WaitInstanceRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WaitInstanceRequest;

  static equals(a: WaitInstanceRequest | PlainMessage<WaitInstanceRequest> | undefined, b: WaitInstanceRequest | PlainMessage<WaitInstanceRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.WaitInstanceResponse
 */
export declare class WaitInstanceResponse extends Message<WaitInstanceResponse> {
  /**
   * The up-to-date metadata of the specified instance.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata metadata = 1;
   */
  metadata?: InstanceMetadata;

  /**
   * If a container is specified, its status.
   *
   * @generated from field: string container_status = 2;
   */
  containerStatus: string;

  constructor(data?: PartialMessage<WaitInstanceResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.WaitInstanceResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WaitInstanceResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WaitInstanceResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WaitInstanceResponse;

  static equals(a: WaitInstanceResponse | PlainMessage<WaitInstanceResponse> | undefined, b: WaitInstanceResponse | PlainMessage<WaitInstanceResponse> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ExtendInstanceRequest
 */
export declare class ExtendInstanceRequest extends Message<ExtendInstanceRequest> {
  /**
   * The ID of the instance which should be extended.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  /**
   * The duration this instance should be extended by.
   *
   * Note: In JSON format, the Duration type is encoded as a string rather than an
   * object, where the string ends in the suffix "s" (indicating seconds) and
   * is preceded by the number of seconds, with nanoseconds expressed as
   * fractional seconds.
   *
   * @generated from field: google.protobuf.Duration extend_by = 2;
   */
  extendBy?: Duration;

  /**
   * The minimum duration this instance should be running.
   *
   * Note: In JSON format, the Duration type is encoded as a string rather than an
   * object, where the string ends in the suffix "s" (indicating seconds) and
   * is preceded by the number of seconds, with nanoseconds expressed as
   * fractional seconds.
   *
   * @generated from field: google.protobuf.Duration ensure_minimum = 3;
   */
  ensureMinimum?: Duration;

  /**
   * The new deadline (in UTC) at which the instance is destroyed.
   *
   * Note: In JSON format, the Timestamp type is encoded as a string in the
   * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
   *
   * @generated from field: google.protobuf.Timestamp new_deadline = 4;
   */
  newDeadline?: Timestamp;

  constructor(data?: PartialMessage<ExtendInstanceRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ExtendInstanceRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtendInstanceRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtendInstanceRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtendInstanceRequest;

  static equals(a: ExtendInstanceRequest | PlainMessage<ExtendInstanceRequest> | undefined, b: ExtendInstanceRequest | PlainMessage<ExtendInstanceRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ExtendInstanceResponse
 */
export declare class ExtendInstanceResponse extends Message<ExtendInstanceResponse> {
  /**
   * The new deadline at which the instance is destroyed.
   *
   * @generated from field: google.protobuf.Timestamp new_deadline = 1;
   */
  newDeadline?: Timestamp;

  constructor(data?: PartialMessage<ExtendInstanceResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ExtendInstanceResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtendInstanceResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtendInstanceResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtendInstanceResponse;

  static equals(a: ExtendInstanceResponse | PlainMessage<ExtendInstanceResponse> | undefined, b: ExtendInstanceResponse | PlainMessage<ExtendInstanceResponse> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.DestroyInstanceRequest
 */
export declare class DestroyInstanceRequest extends Message<DestroyInstanceRequest> {
  /**
   * The ID of instance which this call targets.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  /**
   * The reason of destruction is persisted with the instance and can be
   * retrieved later.
   *
   * @generated from field: string reason = 2;
   */
  reason: string;

  constructor(data?: PartialMessage<DestroyInstanceRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.DestroyInstanceRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DestroyInstanceRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DestroyInstanceRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DestroyInstanceRequest;

  static equals(a: DestroyInstanceRequest | PlainMessage<DestroyInstanceRequest> | undefined, b: DestroyInstanceRequest | PlainMessage<DestroyInstanceRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListInstancesRequest
 */
export declare class ListInstancesRequest extends Message<ListInstancesRequest> {
  /**
   * If a previous response returned a `pagination_cursor`, it can be
   * specified to continue reading results with the same arguments as the
   * original call.
   *
   * @generated from field: bytes pagination_cursor = 1;
   */
  paginationCursor: Uint8Array;

  /**
   * The maximum number of entries to return as part of this ListInstances
   * request. A maximum number of entries may also be specified when
   * `pagination_cursor` is set.
   *
   * We won't return more than `max_entries`, but may return fewer.
   *
   * @generated from field: int64 max_entries = 2;
   */
  maxEntries: bigint;

  /**
   * If not set, only returns instances in the PENDING, CREATING or RUNNING
   * states.
   *
   * If set, also includes instances in the DESTROYED and ERROR states.
   *
   * @generated from field: bool include_complete_runs = 3;
   */
  includeCompleteRuns: boolean;

  /**
   * Don't return instances that were created before the specified timestamp
   * (in UTC).
   *
   * Note: In JSON format, the Timestamp type is encoded as a string in the
   * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
   *
   * @generated from field: google.protobuf.Timestamp not_older_than = 4;
   */
  notOlderThan?: Timestamp;

  /**
   * Only return instances that match the specified filter.
   *
   * @generated from field: repeated namespace.stdlib.LabelFilterEntry label_filter = 5;
   */
  labelFilter: LabelFilterEntry[];

  constructor(data?: PartialMessage<ListInstancesRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListInstancesRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInstancesRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInstancesRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInstancesRequest;

  static equals(a: ListInstancesRequest | PlainMessage<ListInstancesRequest> | undefined, b: ListInstancesRequest | PlainMessage<ListInstancesRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListInstancesResponse
 */
export declare class ListInstancesResponse extends Message<ListInstancesResponse> {
  /**
   * The list of instances that match the filter.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.InstanceMetadata instances = 1;
   */
  instances: InstanceMetadata[];

  /**
   * If set, there are additional results. Pass the same cursor to a
   * subsequent ListInstances call to continue fetching results.
   *
   * @generated from field: bytes pagination_cursor = 2;
   */
  paginationCursor: Uint8Array;

  constructor(data?: PartialMessage<ListInstancesResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListInstancesResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInstancesResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInstancesResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInstancesResponse;

  static equals(a: ListInstancesResponse | PlainMessage<ListInstancesResponse> | undefined, b: ListInstancesResponse | PlainMessage<ListInstancesResponse> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ContainerPort
 */
export declare class ContainerPort extends Message<ContainerPort> {
  /**
   * The protocol the port being expose uses. Must be set.
   *
   * If the protocol is set to `HTTP` then the platform exposes the port using
   * a HTTPS-terminating reverse proxy, which then communicates using http
   * (and not https) with the container.
   *
   * If the protocol is `TCP` then the platform exposes the port using TLS,
   * requiring a Namespace-issued certificate for authentication.
   *
   * Example: `HTTP`
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerPort.Proto proto = 1;
   */
  proto: ContainerPort_Proto;

  /**
   * The port the container is listening on. For example, if exposing a HTTP
   * server, with `proto=HTTP`, the port the http server is listening on.
   *
   * Example: `3000`
   *
   * @generated from field: int32 container_port = 2;
   */
  containerPort: number;

  /**
   * If a name is provided, it is used to generate the Internet-facing server
   * name used to access this port. If it's not provided, a random id is used.
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * A set of rules that configure the ingress when accessing this exported
   * port. Only settable with `proto` is `HTTP`.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.HttpMatchRule http_match_rule = 3;
   */
  httpMatchRule: HttpMatchRule[];

  constructor(data?: PartialMessage<ContainerPort>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ContainerPort";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContainerPort;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContainerPort;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContainerPort;

  static equals(a: ContainerPort | PlainMessage<ContainerPort> | undefined, b: ContainerPort | PlainMessage<ContainerPort> | undefined): boolean;
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.ContainerPort.Proto
 */
export declare enum ContainerPort_Proto {
  /**
   * @generated from enum value: PROTO_UNKNOWN = 0;
   */
  PROTO_UNKNOWN = 0,

  /**
   * @generated from enum value: HTTP = 1;
   */
  HTTP = 1,

  /**
   * @generated from enum value: TCP = 2;
   */
  TCP = 2,
}

/**
 * @generated from message namespace.cloud.compute.v1beta.HttpMatchRule
 */
export declare class HttpMatchRule extends Message<HttpMatchRule> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.HttpMatchRule.HttpMatch match = 1;
   */
  match?: HttpMatchRule_HttpMatch;

  /**
   * @generated from field: bool does_not_require_auth = 2;
   */
  doesNotRequireAuth: boolean;

  constructor(data?: PartialMessage<HttpMatchRule>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.HttpMatchRule";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpMatchRule;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpMatchRule;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpMatchRule;

  static equals(a: HttpMatchRule | PlainMessage<HttpMatchRule> | undefined, b: HttpMatchRule | PlainMessage<HttpMatchRule> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.HttpMatchRule.HttpMatch
 */
export declare class HttpMatchRule_HttpMatch extends Message<HttpMatchRule_HttpMatch> {
  /**
   * If empty, matches any method.
   *
   * @generated from field: repeated string method = 1;
   */
  method: string[];

  /**
   * If empty, matches any path.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  constructor(data?: PartialMessage<HttpMatchRule_HttpMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.HttpMatchRule.HttpMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpMatchRule_HttpMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpMatchRule_HttpMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpMatchRule_HttpMatch;

  static equals(a: HttpMatchRule_HttpMatch | PlainMessage<HttpMatchRule_HttpMatch> | undefined, b: HttpMatchRule_HttpMatch | PlainMessage<HttpMatchRule_HttpMatch> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AllocatedContainer
 */
export declare class AllocatedContainer extends Message<AllocatedContainer> {
  /**
   * A Namespace-allocated ID for this container.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The user specified container name.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The allocated exported ports, which include the allocated public ingress
   * URLs.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.AllocatedContainer.ExportedContainerPort exported_port = 3;
   */
  exportedPort: AllocatedContainer_ExportedContainerPort[];

  constructor(data?: PartialMessage<AllocatedContainer>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AllocatedContainer";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllocatedContainer;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllocatedContainer;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllocatedContainer;

  static equals(a: AllocatedContainer | PlainMessage<AllocatedContainer> | undefined, b: AllocatedContainer | PlainMessage<AllocatedContainer> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AllocatedContainer.ExportedContainerPort
 */
export declare class AllocatedContainer_ExportedContainerPort extends Message<AllocatedContainer_ExportedContainerPort> {
  /**
   * The original specified protocol.
   *
   * @generated from field: namespace.cloud.compute.v1beta.ContainerPort.Proto proto = 1;
   */
  proto: ContainerPort_Proto;

  /**
   * The original specified container port.
   *
   * @generated from field: int32 container_port = 2;
   */
  containerPort: number;

  /**
   * The original specified http rules.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.HttpMatchRule http_match_rule = 3;
   */
  httpMatchRule: HttpMatchRule[];

  /**
   * If required, the port exposed within the instance that translates to
   * the container port above. This port is available in host networking
   * only.
   *
   * @generated from field: int32 exported_port = 4;
   */
  exportedPort: number;

  /**
   * The fully qualified domain that is configured in the public ingress
   * to map back to this exposed port. Check `endpoint` for the hostname
   * and port required to connect to the port.
   *
   * @generated from field: string fqdn = 5;
   */
  fqdn: string;

  /**
   * The endpoint to use to connect to the exported port. May include a
   * port number as well, e.g. "foo-xyz.ord.namespaced.app:444".
   *
   * @generated from field: string endpoint = 6;
   */
  endpoint: string;

  constructor(data?: PartialMessage<AllocatedContainer_ExportedContainerPort>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AllocatedContainer.ExportedContainerPort";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllocatedContainer_ExportedContainerPort;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllocatedContainer_ExportedContainerPort;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllocatedContainer_ExportedContainerPort;

  static equals(a: AllocatedContainer_ExportedContainerPort | PlainMessage<AllocatedContainer_ExportedContainerPort> | undefined, b: AllocatedContainer_ExportedContainerPort | PlainMessage<AllocatedContainer_ExportedContainerPort> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.SuspendInstanceRequest
 */
export declare class SuspendInstanceRequest extends Message<SuspendInstanceRequest> {
  /**
   * The ID of instance which this call targets.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  constructor(data?: PartialMessage<SuspendInstanceRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.SuspendInstanceRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SuspendInstanceRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SuspendInstanceRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SuspendInstanceRequest;

  static equals(a: SuspendInstanceRequest | PlainMessage<SuspendInstanceRequest> | undefined, b: SuspendInstanceRequest | PlainMessage<SuspendInstanceRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.WakeInstanceRequest
 */
export declare class WakeInstanceRequest extends Message<WakeInstanceRequest> {
  /**
   * The ID of instance which this call targets.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  constructor(data?: PartialMessage<WakeInstanceRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.WakeInstanceRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WakeInstanceRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WakeInstanceRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WakeInstanceRequest;

  static equals(a: WakeInstanceRequest | PlainMessage<WakeInstanceRequest> | undefined, b: WakeInstanceRequest | PlainMessage<WakeInstanceRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceExtendedMetadata
 */
export declare class InstanceExtendedMetadata extends Message<InstanceExtendedMetadata> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.InstanceExtendedMetadata.SshMetadata ssh_metadata = 1;
   */
  sshMetadata?: InstanceExtendedMetadata_SshMetadata;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.InstanceExtendedMetadata.KubernetesInstanceMetadata kubernetes_metadata = 2;
   */
  kubernetesMetadata?: InstanceExtendedMetadata_KubernetesInstanceMetadata;

  /**
   * @generated from field: repeated namespace.cloud.compute.v1beta.InstanceExtendedMetadata.AllocatedTlsBackedPort tls_backed_port = 3;
   */
  tlsBackedPort: InstanceExtendedMetadata_AllocatedTlsBackedPort[];

  /**
   * @generated from field: string command_service_endpoint = 4;
   */
  commandServiceEndpoint: string;

  constructor(data?: PartialMessage<InstanceExtendedMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceExtendedMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceExtendedMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata;

  static equals(a: InstanceExtendedMetadata | PlainMessage<InstanceExtendedMetadata> | undefined, b: InstanceExtendedMetadata | PlainMessage<InstanceExtendedMetadata> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceExtendedMetadata.SshMetadata
 */
export declare class InstanceExtendedMetadata_SshMetadata extends Message<InstanceExtendedMetadata_SshMetadata> {
  /**
   * @generated from field: string ssh_proxy_endpoint = 1;
   */
  sshProxyEndpoint: string;

  /**
   * @generated from field: bytes ssh_private_key = 2;
   */
  sshPrivateKey: Uint8Array;

  constructor(data?: PartialMessage<InstanceExtendedMetadata_SshMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceExtendedMetadata.SshMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceExtendedMetadata_SshMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata_SshMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata_SshMetadata;

  static equals(a: InstanceExtendedMetadata_SshMetadata | PlainMessage<InstanceExtendedMetadata_SshMetadata> | undefined, b: InstanceExtendedMetadata_SshMetadata | PlainMessage<InstanceExtendedMetadata_SshMetadata> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceExtendedMetadata.KubernetesInstanceMetadata
 */
export declare class InstanceExtendedMetadata_KubernetesInstanceMetadata extends Message<InstanceExtendedMetadata_KubernetesInstanceMetadata> {
  /**
   * @generated from field: string endpoint_address = 1;
   */
  endpointAddress: string;

  /**
   * @generated from field: bytes certificate_authority_data = 2;
   */
  certificateAuthorityData: Uint8Array;

  /**
   * @generated from field: bytes client_certificate_data = 3;
   */
  clientCertificateData: Uint8Array;

  /**
   * @generated from field: bytes client_key_data = 4;
   */
  clientKeyData: Uint8Array;

  /**
   * @generated from field: string kubernetes_distribution = 5;
   */
  kubernetesDistribution: string;

  constructor(data?: PartialMessage<InstanceExtendedMetadata_KubernetesInstanceMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceExtendedMetadata.KubernetesInstanceMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceExtendedMetadata_KubernetesInstanceMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata_KubernetesInstanceMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata_KubernetesInstanceMetadata;

  static equals(a: InstanceExtendedMetadata_KubernetesInstanceMetadata | PlainMessage<InstanceExtendedMetadata_KubernetesInstanceMetadata> | undefined, b: InstanceExtendedMetadata_KubernetesInstanceMetadata | PlainMessage<InstanceExtendedMetadata_KubernetesInstanceMetadata> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceExtendedMetadata.AllocatedTlsBackedPort
 */
export declare class InstanceExtendedMetadata_AllocatedTlsBackedPort extends Message<InstanceExtendedMetadata_AllocatedTlsBackedPort> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: int32 port = 2;
   */
  port: number;

  /**
   * @generated from field: string server_name = 3;
   */
  serverName: string;

  constructor(data?: PartialMessage<InstanceExtendedMetadata_AllocatedTlsBackedPort>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceExtendedMetadata.AllocatedTlsBackedPort";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceExtendedMetadata_AllocatedTlsBackedPort;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata_AllocatedTlsBackedPort;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceExtendedMetadata_AllocatedTlsBackedPort;

  static equals(a: InstanceExtendedMetadata_AllocatedTlsBackedPort | PlainMessage<InstanceExtendedMetadata_AllocatedTlsBackedPort> | undefined, b: InstanceExtendedMetadata_AllocatedTlsBackedPort | PlainMessage<InstanceExtendedMetadata_AllocatedTlsBackedPort> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceMetadata
 */
export declare class InstanceMetadata extends Message<InstanceMetadata> {
  /**
   * The ID of the instance created.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  /**
   * The timestamp of when the instance was created (in UTC).
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * The timestamp of when the instance was destroyed (in UTC). Not set if the
   * instance is one of PENDING, CREATING or RUNNING states.
   *
   * @generated from field: google.protobuf.Timestamp destroyed_at = 3;
   */
  destroyedAt?: Timestamp;

  /**
   * The computed deadline of the instance (in UTC). The instance will be
   * garbage collected when it his its deadline.
   *
   * @generated from field: google.protobuf.Timestamp deadline = 4;
   */
  deadline?: Timestamp;

  /**
   * The user specified documented purpose.
   *
   * @generated from field: string documented_purpose = 5;
   */
  documentedPurpose: string;

  /**
   * The user specified instance shape (cpu, memory, disk).
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceShape shape = 6;
   */
  shape?: InstanceShape;

  /**
   * The status the instance is in.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata.Status status = 7;
   */
  status: InstanceMetadata_Status;

  /**
   * The region-specific base ingress domain used to back created ingresses.
   *
   * Example: `fra1.nscluster.cloud`.
   *
   * @generated from field: string ingress_domain = 8;
   */
  ingressDomain: string;

  /**
   * The user specified instance labels.
   *
   * @generated from field: repeated namespace.stdlib.Label labels = 9;
   */
  labels: Label[];

  /**
   * If the used authorization token has a `creator_id`, it is retained for
   * debugging purposes.
   *
   * @generated from field: string creator_id = 10;
   */
  creatorId: string;

  /**
   * Maintain state of each of the exported system services in this instance.
   * Examples of system services are `buildkit`, `kubernetes`, etc.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.InstanceMetadata.Service services = 11;
   */
  services: InstanceMetadata_Service[];

  /**
   * Information related to where the instance is running, or ran, including
   * geography, and hw platform.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata.HWDeployment hw_deployment = 12;
   */
  hwDeployment?: InstanceMetadata_HWDeployment;

  constructor(data?: PartialMessage<InstanceMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceMetadata;

  static equals(a: InstanceMetadata | PlainMessage<InstanceMetadata> | undefined, b: InstanceMetadata | PlainMessage<InstanceMetadata> | undefined): boolean;
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.InstanceMetadata.Status
 */
export declare enum InstanceMetadata_Status {
  /**
   * @generated from enum value: STATUS_UNKNOWN = 0;
   */
  STATUS_UNKNOWN = 0,

  /**
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * @generated from enum value: CREATING = 2;
   */
  CREATING = 2,

  /**
   * @generated from enum value: RUNNING = 3;
   */
  RUNNING = 3,

  /**
   * @generated from enum value: DESTROYED = 4;
   */
  DESTROYED = 4,

  /**
   * @generated from enum value: DESTROYING = 5;
   */
  DESTROYING = 5,

  /**
   * @generated from enum value: SUSPENDING = 6;
   */
  SUSPENDING = 6,

  /**
   * @generated from enum value: SUSPENDED = 7;
   */
  SUSPENDED = 7,

  /**
   * @generated from enum value: ERROR = 8;
   */
  ERROR = 8,
}

/**
 * A service represents an internal service that is proxiable when an
 * authenticated request is performed that proves that the caller has access
 * to the instance.
 *
 * Access to services does not follow the gRPC service model, and goes over
 * Namespace's programmable ingress directly, being a mix of either
 * WebSocket- or HTTP-backed implementations.
 *
 * @generated from message namespace.cloud.compute.v1beta.InstanceMetadata.Service
 */
export declare class InstanceMetadata_Service extends Message<InstanceMetadata_Service> {
  /**
   * The name of the service, e.g. "ssh", "docker" or "containerd".
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * It's current status, one of PENDING or READY.
   *
   * Note: It's not guaranteed that all services emit a PENDING state
   * before becoming READY. The fact that they're starting can sometimes
   * result in a lack of a ServiceState entry for that service.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata.Service.Status status = 2;
   */
  status: InstanceMetadata_Service_Status;

  /**
   * Identifies what application transport this endpoint implements.
   *
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata.Service.EndpointKind endpoint_kind = 3;
   */
  endpointKind: InstanceMetadata_Service_EndpointKind;

  /**
   * The application-specific endpoint. Typically a URL.
   *
   * Example: `wss://gate.fra1.nscluster.cloud/ui3e3e3g7cfrg/22`
   *
   * @generated from field: string endpoint = 4;
   */
  endpoint: string;

  constructor(data?: PartialMessage<InstanceMetadata_Service>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceMetadata.Service";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceMetadata_Service;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceMetadata_Service;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceMetadata_Service;

  static equals(a: InstanceMetadata_Service | PlainMessage<InstanceMetadata_Service> | undefined, b: InstanceMetadata_Service | PlainMessage<InstanceMetadata_Service> | undefined): boolean;
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.InstanceMetadata.Service.Status
 */
export declare enum InstanceMetadata_Service_Status {
  /**
   * @generated from enum value: STATUS_UNKNOWN = 0;
   */
  STATUS_UNKNOWN = 0,

  /**
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * @generated from enum value: READY = 2;
   */
  READY = 2,
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.InstanceMetadata.Service.EndpointKind
 */
export declare enum InstanceMetadata_Service_EndpointKind {
  /**
   * @generated from enum value: ENDPOINT_KIND_UNKNOWN = 0;
   */
  ENDPOINT_KIND_UNKNOWN = 0,

  /**
   * The service is a regular HTTP 1.1/2 service with a TLS frontend.
   *
   * Authentication is provided using a Bearer token passed to the
   * ingress on a `x-nsc-ingress-auth` header.
   *
   * @generated from enum value: HTTPS = 1;
   */
  HTTPS = 1,

  /**
   * The service proxies an API which maps back to an
   * application-specific transport, with messages following an
   * application-specific framing and transmitted over a secure
   * WebSocket, using BinaryMessage.
   *
   * For example, when accessing the docker service, the websocket
   * serves the same stream as one would get if connecting locally to
   * the dockerd socket over Unix Sockets.
   *
   * Authentication is provided using a Bearer token passed to the
   * ingress on either:
   * - Via a `x-nsc-ingress-auth` header, with a `Bearer` prefix, e.g.
   *   `Bearer nsct_abc...`.
   * - By specifying a query argument `x-nsc-ingress-auth` where the
   *   value is the token itself, e.g. `?x-nsc-ingress-auth=abc...`.
   *
   * @generated from enum value: PROXY_OVER_SECURE_WEBSOCKET = 2;
   */
  PROXY_OVER_SECURE_WEBSOCKET = 2,
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceMetadata.ShutdownReason
 */
export declare class InstanceMetadata_ShutdownReason extends Message<InstanceMetadata_ShutdownReason> {
  /**
   * @generated from field: int32 error_code = 1;
   */
  errorCode: number;

  /**
   * @generated from field: string error_message = 2;
   */
  errorMessage: string;

  /**
   * @generated from field: string container_nsc_id = 3;
   */
  containerNscId: string;

  /**
   * @generated from field: string container_name = 4;
   */
  containerName: string;

  /**
   * @generated from field: string container_failed_reason = 5;
   */
  containerFailedReason: string;

  constructor(data?: PartialMessage<InstanceMetadata_ShutdownReason>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceMetadata.ShutdownReason";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceMetadata_ShutdownReason;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceMetadata_ShutdownReason;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceMetadata_ShutdownReason;

  static equals(a: InstanceMetadata_ShutdownReason | PlainMessage<InstanceMetadata_ShutdownReason> | undefined, b: InstanceMetadata_ShutdownReason | PlainMessage<InstanceMetadata_ShutdownReason> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceMetadata.HWDeployment
 */
export declare class InstanceMetadata_HWDeployment extends Message<InstanceMetadata_HWDeployment> {
  /**
   * In which continent was the instance deployed to, one of "us" or "eu".
   *
   * @generated from field: string geo_continent = 1;
   */
  geoContinent: string;

  /**
   * What hardware platform was the instance deployed to, one of "a1", "a2", "mac-m2" or "arm2".
   *
   * @generated from field: string major_hwplatform = 2;
   */
  majorHwplatform: string;

  constructor(data?: PartialMessage<InstanceMetadata_HWDeployment>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceMetadata.HWDeployment";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceMetadata_HWDeployment;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceMetadata_HWDeployment;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceMetadata_HWDeployment;

  static equals(a: InstanceMetadata_HWDeployment | PlainMessage<InstanceMetadata_HWDeployment> | undefined, b: InstanceMetadata_HWDeployment | PlainMessage<InstanceMetadata_HWDeployment> | undefined): boolean;
}

/**
 * Defines an instance shape: the combination of CPU, RAM and Disk that the
 * instance should use.
 *
 * Usable values are constrained by policy, and are typically only settable in
 * values as powers of two.
 *
 * @generated from message namespace.cloud.compute.v1beta.InstanceShape
 */
export declare class InstanceShape extends Message<InstanceShape> {
  /**
   * @generated from field: int32 virtual_cpu = 1;
   */
  virtualCpu: number;

  /**
   * @generated from field: int32 memory_megabytes = 2;
   */
  memoryMegabytes: number;

  /**
   * Architecture of the instance, e.g. "amd64" or "arm64".
   *
   * @generated from field: string machine_arch = 3;
   */
  machineArch: string;

  /**
   * Operating system of the instance, e.g. "linux" or "macos".
   *
   * @generated from field: string os = 4;
   */
  os: string;

  /**
   * Provide additional constraints to instance selection. Available selectors:
   * https://namespace.so/docs/architecture/compute/macos#available-selectors
   *
   * @generated from field: repeated namespace.stdlib.Label selectors = 5;
   */
  selectors: Label[];

  constructor(data?: PartialMessage<InstanceShape>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceShape";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceShape;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceShape;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceShape;

  static equals(a: InstanceShape | PlainMessage<InstanceShape> | undefined, b: InstanceShape | PlainMessage<InstanceShape> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ImageRegistry
 */
export declare class ImageRegistry extends Message<ImageRegistry> {
  /**
   * @generated from field: string endpoint_address = 1;
   */
  endpointAddress: string;

  /**
   * @generated from field: string repository = 2;
   */
  repository: string;

  constructor(data?: PartialMessage<ImageRegistry>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ImageRegistry";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageRegistry;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageRegistry;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageRegistry;

  static equals(a: ImageRegistry | PlainMessage<ImageRegistry> | undefined, b: ImageRegistry | PlainMessage<ImageRegistry> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateIngressRequest
 */
export declare class CreateIngressRequest extends Message<CreateIngressRequest> {
  /**
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  /**
   * @generated from field: repeated namespace.cloud.compute.v1beta.IngressRequest ingresses = 2;
   */
  ingresses: IngressRequest[];

  constructor(data?: PartialMessage<CreateIngressRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateIngressRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateIngressRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateIngressRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateIngressRequest;

  static equals(a: CreateIngressRequest | PlainMessage<CreateIngressRequest> | undefined, b: CreateIngressRequest | PlainMessage<CreateIngressRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.IngressRequest
 */
export declare class IngressRequest extends Message<IngressRequest> {
  /**
   * A name is an string that matches the regular expression `[a-z0-9]([a-z0-9-_]*[a-z0-9])?`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: repeated namespace.cloud.compute.v1beta.HttpMatchRule http_match_rule = 2;
   */
  httpMatchRule: HttpMatchRule[];

  /**
   * @generated from field: namespace.cloud.compute.v1beta.ExportedPortBackend exported_port_backend = 3;
   */
  exportedPortBackend?: ExportedPortBackend;

  /**
   * Routes all first-level sub domains of the instance wildcard domain to this ingress.
   * Requires the hosting instance to have a wildcard domain (enabled via CreateInstanceRequest.experimental.enable_wildcard_domain).
   *
   * @generated from field: bool wildcard = 4;
   */
  wildcard: boolean;

  constructor(data?: PartialMessage<IngressRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.IngressRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IngressRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IngressRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IngressRequest;

  static equals(a: IngressRequest | PlainMessage<IngressRequest> | undefined, b: IngressRequest | PlainMessage<IngressRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.CreateIngressResponse
 */
export declare class CreateIngressResponse extends Message<CreateIngressResponse> {
  /**
   * @generated from field: repeated namespace.cloud.compute.v1beta.AllocatedIngress allocated_ingresses = 1;
   */
  allocatedIngresses: AllocatedIngress[];

  constructor(data?: PartialMessage<CreateIngressResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.CreateIngressResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateIngressResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateIngressResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateIngressResponse;

  static equals(a: CreateIngressResponse | PlainMessage<CreateIngressResponse> | undefined, b: CreateIngressResponse | PlainMessage<CreateIngressResponse> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListIngressesRequest
 */
export declare class ListIngressesRequest extends Message<ListIngressesRequest> {
  /**
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  constructor(data?: PartialMessage<ListIngressesRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListIngressesRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIngressesRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIngressesRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIngressesRequest;

  static equals(a: ListIngressesRequest | PlainMessage<ListIngressesRequest> | undefined, b: ListIngressesRequest | PlainMessage<ListIngressesRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListIngressesResponse
 */
export declare class ListIngressesResponse extends Message<ListIngressesResponse> {
  /**
   * @generated from field: repeated namespace.cloud.compute.v1beta.AllocatedIngress allocated_ingresses = 1;
   */
  allocatedIngresses: AllocatedIngress[];

  constructor(data?: PartialMessage<ListIngressesResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListIngressesResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIngressesResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIngressesResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIngressesResponse;

  static equals(a: ListIngressesResponse | PlainMessage<ListIngressesResponse> | undefined, b: ListIngressesResponse | PlainMessage<ListIngressesResponse> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.AllocatedIngress
 */
export declare class AllocatedIngress extends Message<AllocatedIngress> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string fqdn = 2;
   */
  fqdn: string;

  /**
   * @generated from field: string description = 3;
   */
  description: string;

  constructor(data?: PartialMessage<AllocatedIngress>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.AllocatedIngress";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllocatedIngress;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllocatedIngress;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllocatedIngress;

  static equals(a: AllocatedIngress | PlainMessage<AllocatedIngress> | undefined, b: AllocatedIngress | PlainMessage<AllocatedIngress> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ExportedPortBackend
 */
export declare class ExportedPortBackend extends Message<ExportedPortBackend> {
  /**
   * @generated from field: int32 port = 1;
   */
  port: number;

  constructor(data?: PartialMessage<ExportedPortBackend>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ExportedPortBackend";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportedPortBackend;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportedPortBackend;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportedPortBackend;

  static equals(a: ExportedPortBackend | PlainMessage<ExportedPortBackend> | undefined, b: ExportedPortBackend | PlainMessage<ExportedPortBackend> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetKubernetesConfigRequest
 */
export declare class GetKubernetesConfigRequest extends Message<GetKubernetesConfigRequest> {
  /**
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  constructor(data?: PartialMessage<GetKubernetesConfigRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetKubernetesConfigRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKubernetesConfigRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKubernetesConfigRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKubernetesConfigRequest;

  static equals(a: GetKubernetesConfigRequest | PlainMessage<GetKubernetesConfigRequest> | undefined, b: GetKubernetesConfigRequest | PlainMessage<GetKubernetesConfigRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetKubernetesConfigResponse
 */
export declare class GetKubernetesConfigResponse extends Message<GetKubernetesConfigResponse> {
  /**
   * @generated from field: string kubeconfig = 1;
   */
  kubeconfig: string;

  constructor(data?: PartialMessage<GetKubernetesConfigResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetKubernetesConfigResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKubernetesConfigResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKubernetesConfigResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKubernetesConfigResponse;

  static equals(a: GetKubernetesConfigResponse | PlainMessage<GetKubernetesConfigResponse> | undefined, b: GetKubernetesConfigResponse | PlainMessage<GetKubernetesConfigResponse> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.VolumeRequest
 */
export declare class VolumeRequest extends Message<VolumeRequest> {
  /**
   * @generated from field: string mount_point = 1;
   */
  mountPoint: string;

  /**
   * @generated from field: string tag = 2;
   */
  tag: string;

  /**
   * @generated from field: int64 size_mb = 3;
   */
  sizeMb: bigint;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.VolumeRequest.PersistencyKind persistency_kind = 4;
   */
  persistencyKind: VolumeRequest_PersistencyKind;

  constructor(data?: PartialMessage<VolumeRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.VolumeRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VolumeRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VolumeRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VolumeRequest;

  static equals(a: VolumeRequest | PlainMessage<VolumeRequest> | undefined, b: VolumeRequest | PlainMessage<VolumeRequest> | undefined): boolean;
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.VolumeRequest.PersistencyKind
 */
export declare enum VolumeRequest_PersistencyKind {
  /**
   * @generated from enum value: PERSISTENCY_UNKNOWN = 0;
   */
  PERSISTENCY_UNKNOWN = 0,

  /**
   * @generated from enum value: PERSISTENT = 1;
   */
  PERSISTENT = 1,

  /**
   * @generated from enum value: CACHE = 2;
   */
  CACHE = 2,
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetInstanceMetricsRequest
 */
export declare class GetInstanceMetricsRequest extends Message<GetInstanceMetricsRequest> {
  /**
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  /**
   * If set, only metrics data on or after this timestamp will be returned.
   *
   * Note: In JSON format, the Timestamp type is encoded as a string in the
   * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
   *
   * @generated from field: google.protobuf.Timestamp start_timestamp = 2;
   */
  startTimestamp?: Timestamp;

  /**
   * If set, only metrics data up to this timestamp will be returned.
   *
   * Note: In JSON format, the Timestamp type is encoded as a string in the
   * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
   *
   * @generated from field: google.protobuf.Timestamp end_timestamp = 3;
   */
  endTimestamp?: Timestamp;

  /**
   * Specifies which metrics should be returned.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.GetInstanceMetricsRequest.MetricResource metric_resource = 4;
   */
  metricResource: GetInstanceMetricsRequest_MetricResource[];

  constructor(data?: PartialMessage<GetInstanceMetricsRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetInstanceMetricsRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetInstanceMetricsRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetInstanceMetricsRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetInstanceMetricsRequest;

  static equals(a: GetInstanceMetricsRequest | PlainMessage<GetInstanceMetricsRequest> | undefined, b: GetInstanceMetricsRequest | PlainMessage<GetInstanceMetricsRequest> | undefined): boolean;
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.GetInstanceMetricsRequest.MetricResource
 */
export declare enum GetInstanceMetricsRequest_MetricResource {
  /**
   * @generated from enum value: METRIC_UNSPECIFIED = 0;
   */
  METRIC_UNSPECIFIED = 0,

  /**
   * CPU usage.
   * Provides the metrics:
   * "cpu_max" (Doubles, 0..100):
   *    For each time interval, CPU utilization of the most utilized CPU.
   * "cpu_avg" (Doubles, 0 ..100):
   *    For each time interval, average CPU utilization between all CPUs.
   *
   * @generated from enum value: CPU = 1;
   */
  CPU = 1,

  /**
   * CPU usage per CPU.
   * For each CPU <n> (n = 0 .. number of CPUs - 1), provides the metrics:
   * "cpu_<n>" (Doubles, 0..100):
   *    CPU Utilization in the time interval for CPU <n>.
   *
   * @generated from enum value: CPU_BREAKDOWN = 2;
   */
  CPU_BREAKDOWN = 2,

  /**
   * IO wait time percentage.
   * Provides the metrics:
   * "io_wait_max" (Doubles, 0..100):
   *   For each time interval, max percentage of time spent waiting on IO
   *   between the CPUs.
   * "io_wait_avg" (Doubles, 0..100):
   *   For each time interval, average percentage of time all CPUs spent
   *   waiting on IO.
   *
   * @generated from enum value: IO_WAIT = 3;
   */
  IO_WAIT = 3,

  /**
   * Memory usage.
   * Provides the metrics:
   * "mem_available" (Integers, in bytes):
   *   Available memory size, in bytes.
   * "mem_used" (Integers, in bytes):
   *   Used memory size, in bytes.
   *
   * @generated from enum value: MEMORY = 4;
   */
  MEMORY = 4,

  /**
   * Storage information.
   * For each mounted volume <mountpoint>, provides the metrics:
   * "storage_used_percent_<mountpoint>" (Doubles, 0..100):
   *   Percentage of available storage capacity that is in use.
   *   "/" is the root ephemeral storage mountpoint.
   *   Other mountpoints are caches.
   *
   * @generated from enum value: STORAGE = 5;
   */
  STORAGE = 5,
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetInstanceMetricsResponse
 */
export declare class GetInstanceMetricsResponse extends Message<GetInstanceMetricsResponse> {
  /**
   * The requested metrics will be returned in one or more time series.
   * The assignment of metrics to time series is implementation defined and
   * can change over time, so the client should iterate all time_series when
   * looking for a particular metric.
   *
   * @generated from field: repeated namespace.stdlib.TimeSeries time_series = 1;
   */
  timeSeries: TimeSeries[];

  constructor(data?: PartialMessage<GetInstanceMetricsResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetInstanceMetricsResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetInstanceMetricsResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetInstanceMetricsResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetInstanceMetricsResponse;

  static equals(a: GetInstanceMetricsResponse | PlainMessage<GetInstanceMetricsResponse> | undefined, b: GetInstanceMetricsResponse | PlainMessage<GetInstanceMetricsResponse> | undefined): boolean;
}

/**
 * Used as a error detail.
 *
 * @generated from message namespace.cloud.compute.v1beta.ResourceLimitsError
 */
export declare class ResourceLimitsError extends Message<ResourceLimitsError> {
  /**
   * @generated from field: string description = 5;
   */
  description: string;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.ResourceLimitsError.LimitKind kind = 4;
   */
  kind: ResourceLimitsError_LimitKind;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.ResourceLimitsError.Resource requested = 1;
   */
  requested?: ResourceLimitsError_Resource;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.ResourceLimitsError.Resource used = 2;
   */
  used?: ResourceLimitsError_Resource;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.ResourceLimitsError.Resource limits = 3;
   */
  limits?: ResourceLimitsError_Resource;

  constructor(data?: PartialMessage<ResourceLimitsError>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ResourceLimitsError";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceLimitsError;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceLimitsError;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceLimitsError;

  static equals(a: ResourceLimitsError | PlainMessage<ResourceLimitsError> | undefined, b: ResourceLimitsError | PlainMessage<ResourceLimitsError> | undefined): boolean;
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.ResourceLimitsError.LimitKind
 */
export declare enum ResourceLimitsError_LimitKind {
  /**
   * @generated from enum value: LIMIT_KIND_UNKNOWN = 0;
   */
  LIMIT_KIND_UNKNOWN = 0,

  /**
   * @generated from enum value: CPU_MEMORY_LIMIT = 1;
   */
  CPU_MEMORY_LIMIT = 1,

  /**
   * @generated from enum value: INSTANCE_COUNT_LIMIT = 2;
   */
  INSTANCE_COUNT_LIMIT = 2,
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ResourceLimitsError.Resource
 */
export declare class ResourceLimitsError_Resource extends Message<ResourceLimitsError_Resource> {
  /**
   * @generated from field: int32 virtual_cpu = 1;
   */
  virtualCpu: number;

  /**
   * @generated from field: int32 memory_megabytes = 2;
   */
  memoryMegabytes: number;

  /**
   * @generated from field: int32 instance_count = 3;
   */
  instanceCount: number;

  constructor(data?: PartialMessage<ResourceLimitsError_Resource>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ResourceLimitsError.Resource";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceLimitsError_Resource;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceLimitsError_Resource;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceLimitsError_Resource;

  static equals(a: ResourceLimitsError_Resource | PlainMessage<ResourceLimitsError_Resource> | undefined, b: ResourceLimitsError_Resource | PlainMessage<ResourceLimitsError_Resource> | undefined): boolean;
}

/**
 * Used as a error detail.
 *
 * @generated from message namespace.cloud.compute.v1beta.UsageLimitsError
 */
export declare class UsageLimitsError extends Message<UsageLimitsError> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.UsageLimitsError.Usage used = 1;
   */
  used?: UsageLimitsError_Usage;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.UsageLimitsError.Usage limits = 2;
   */
  limits?: UsageLimitsError_Usage;

  constructor(data?: PartialMessage<UsageLimitsError>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.UsageLimitsError";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageLimitsError;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageLimitsError;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageLimitsError;

  static equals(a: UsageLimitsError | PlainMessage<UsageLimitsError> | undefined, b: UsageLimitsError | PlainMessage<UsageLimitsError> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.UsageLimitsError.Usage
 */
export declare class UsageLimitsError_Usage extends Message<UsageLimitsError_Usage> {
  /**
   * @generated from field: int64 compute_unit_minutes = 1;
   */
  computeUnitMinutes: bigint;

  /**
   * @generated from field: int64 compute_wall_seconds = 2;
   */
  computeWallSeconds: bigint;

  constructor(data?: PartialMessage<UsageLimitsError_Usage>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.UsageLimitsError.Usage";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageLimitsError_Usage;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageLimitsError_Usage;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageLimitsError_Usage;

  static equals(a: UsageLimitsError_Usage | PlainMessage<UsageLimitsError_Usage> | undefined, b: UsageLimitsError_Usage | PlainMessage<UsageLimitsError_Usage> | undefined): boolean;
}

/**
 * Used as a error detail.
 *
 * @generated from message namespace.cloud.compute.v1beta.PlatformNotAllowedError
 */
export declare class PlatformNotAllowedError extends Message<PlatformNotAllowedError> {
  /**
   * @generated from field: string requested_platform = 1;
   */
  requestedPlatform: string;

  /**
   * @generated from field: repeated string allowed_platforms = 2;
   */
  allowedPlatforms: string[];

  constructor(data?: PartialMessage<PlatformNotAllowedError>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.PlatformNotAllowedError";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlatformNotAllowedError;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlatformNotAllowedError;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlatformNotAllowedError;

  static equals(a: PlatformNotAllowedError | PlainMessage<PlatformNotAllowedError> | undefined, b: PlatformNotAllowedError | PlainMessage<PlatformNotAllowedError> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetNetworkConfigurationRequest
 */
export declare class GetNetworkConfigurationRequest extends Message<GetNetworkConfigurationRequest> {
  constructor(data?: PartialMessage<GetNetworkConfigurationRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetNetworkConfigurationRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNetworkConfigurationRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNetworkConfigurationRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNetworkConfigurationRequest;

  static equals(a: GetNetworkConfigurationRequest | PlainMessage<GetNetworkConfigurationRequest> | undefined, b: GetNetworkConfigurationRequest | PlainMessage<GetNetworkConfigurationRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse
 */
export declare class GetNetworkConfigurationResponse extends Message<GetNetworkConfigurationResponse> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.Egress egress = 1;
   */
  egress?: GetNetworkConfigurationResponse_Egress;

  constructor(data?: PartialMessage<GetNetworkConfigurationResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNetworkConfigurationResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNetworkConfigurationResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNetworkConfigurationResponse;

  static equals(a: GetNetworkConfigurationResponse | PlainMessage<GetNetworkConfigurationResponse> | undefined, b: GetNetworkConfigurationResponse | PlainMessage<GetNetworkConfigurationResponse> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.Egress
 */
export declare class GetNetworkConfigurationResponse_Egress extends Message<GetNetworkConfigurationResponse_Egress> {
  /**
   * Possible source addresses used by instances running in this workspace
   * (tenant).
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.CIDR egress_cidrs = 1;
   */
  egressCidrs: GetNetworkConfigurationResponse_CIDR[];

  constructor(data?: PartialMessage<GetNetworkConfigurationResponse_Egress>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.Egress";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNetworkConfigurationResponse_Egress;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNetworkConfigurationResponse_Egress;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNetworkConfigurationResponse_Egress;

  static equals(a: GetNetworkConfigurationResponse_Egress | PlainMessage<GetNetworkConfigurationResponse_Egress> | undefined, b: GetNetworkConfigurationResponse_Egress | PlainMessage<GetNetworkConfigurationResponse_Egress> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.CIDR
 */
export declare class GetNetworkConfigurationResponse_CIDR extends Message<GetNetworkConfigurationResponse_CIDR> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.CIDR.Kind kind = 1;
   */
  kind: GetNetworkConfigurationResponse_CIDR_Kind;

  /**
   * @generated from field: string cidr = 2;
   */
  cidr: string;

  constructor(data?: PartialMessage<GetNetworkConfigurationResponse_CIDR>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.CIDR";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNetworkConfigurationResponse_CIDR;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNetworkConfigurationResponse_CIDR;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNetworkConfigurationResponse_CIDR;

  static equals(a: GetNetworkConfigurationResponse_CIDR | PlainMessage<GetNetworkConfigurationResponse_CIDR> | undefined, b: GetNetworkConfigurationResponse_CIDR | PlainMessage<GetNetworkConfigurationResponse_CIDR> | undefined): boolean;
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.GetNetworkConfigurationResponse.CIDR.Kind
 */
export declare enum GetNetworkConfigurationResponse_CIDR_Kind {
  /**
   * @generated from enum value: KIND_UNKNOWN = 0;
   */
  KIND_UNKNOWN = 0,

  /**
   * @generated from enum value: NAMESPACE_MANAGED = 1;
   */
  NAMESPACE_MANAGED = 1,

  /**
   * @generated from enum value: EXTERNAL_TRANSIT_PROVIDER = 2;
   */
  EXTERNAL_TRANSIT_PROVIDER = 2,
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetSSHConfigRequest
 */
export declare class GetSSHConfigRequest extends Message<GetSSHConfigRequest> {
  /**
   * Required: which instance to provide and SSH configuration for.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  /**
   * Optional: Specify a container name to connect to. The resulting connection endpoint will open a session in that container, if present.
   *
   * @generated from field: string target_container = 2;
   */
  targetContainer: string;

  constructor(data?: PartialMessage<GetSSHConfigRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetSSHConfigRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSSHConfigRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSSHConfigRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSSHConfigRequest;

  static equals(a: GetSSHConfigRequest | PlainMessage<GetSSHConfigRequest> | undefined, b: GetSSHConfigRequest | PlainMessage<GetSSHConfigRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.GetSSHConfigResponse
 */
export declare class GetSSHConfigResponse extends Message<GetSSHConfigResponse> {
  /**
   * If set, this private key can be used to establish an SSH session to the instance.
   * Any private key returned here has limited access rights, restricted to a single instance.
   *
   * @generated from field: bytes ssh_private_key = 1;
   */
  sshPrivateKey: Uint8Array;

  /**
   * Which username to use when establishing an SSH session.
   * E.g. You can start a session from a terminal using `ssh <username>@<endpoint>`.
   *
   * @generated from field: string username = 2;
   */
  username: string;

  /**
   * This SSH endpoint can be used to establish an SSH session with the instance.
   * Make sure to also configure the corresponding username.
   *
   * @generated from field: string endpoint = 3;
   */
  endpoint: string;

  constructor(data?: PartialMessage<GetSSHConfigResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.GetSSHConfigResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSSHConfigResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSSHConfigResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSSHConfigResponse;

  static equals(a: GetSSHConfigResponse | PlainMessage<GetSSHConfigResponse> | undefined, b: GetSSHConfigResponse | PlainMessage<GetSSHConfigResponse> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ReleaseUniqueTagRequest
 */
export declare class ReleaseUniqueTagRequest extends Message<ReleaseUniqueTagRequest> {
  /**
   * The name of the unique tag to release.
   *
   * @generated from field: string unique_tag = 1;
   */
  uniqueTag: string;

  /**
   * If set, only release the unique tag if the currently associated instance ID matches this constraint.
   *
   * When running a container with `nsc_state_path` set, the parent instance ID is available via the environment variable NSC_INSTANCE_ID.
   *
   * @generated from field: namespace.stdlib.StringMatcher if_instance_id = 2;
   */
  ifInstanceId?: StringMatcher;

  constructor(data?: PartialMessage<ReleaseUniqueTagRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ReleaseUniqueTagRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReleaseUniqueTagRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReleaseUniqueTagRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReleaseUniqueTagRequest;

  static equals(a: ReleaseUniqueTagRequest | PlainMessage<ReleaseUniqueTagRequest> | undefined, b: ReleaseUniqueTagRequest | PlainMessage<ReleaseUniqueTagRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ReleaseUniqueTagResponse
 */
export declare class ReleaseUniqueTagResponse extends Message<ReleaseUniqueTagResponse> {
  /**
   * The ID of the instance that was released from the tag.
   * If no instance was released, this field is not set.
   *
   * @generated from field: string instance_id = 1;
   */
  instanceId: string;

  constructor(data?: PartialMessage<ReleaseUniqueTagResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ReleaseUniqueTagResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReleaseUniqueTagResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReleaseUniqueTagResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReleaseUniqueTagResponse;

  static equals(a: ReleaseUniqueTagResponse | PlainMessage<ReleaseUniqueTagResponse> | undefined, b: ReleaseUniqueTagResponse | PlainMessage<ReleaseUniqueTagResponse> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.OptimizeImageRequest
 */
export declare class OptimizeImageRequest extends Message<OptimizeImageRequest> {
  /**
   * @generated from field: string image_ref = 1;
   */
  imageRef: string;

  /**
   * @generated from field: string site = 2;
   */
  site: string;

  constructor(data?: PartialMessage<OptimizeImageRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.OptimizeImageRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptimizeImageRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptimizeImageRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptimizeImageRequest;

  static equals(a: OptimizeImageRequest | PlainMessage<OptimizeImageRequest> | undefined, b: OptimizeImageRequest | PlainMessage<OptimizeImageRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.OptimizeImageProgress
 */
export declare class OptimizeImageProgress extends Message<OptimizeImageProgress> {
  /**
   * @generated from field: namespace.cloud.compute.v1beta.OptimizeImageProgress.Status status = 1;
   */
  status: OptimizeImageProgress_Status;

  /**
   * @generated from field: string baker_instance_id = 2;
   */
  bakerInstanceId: string;

  constructor(data?: PartialMessage<OptimizeImageProgress>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.OptimizeImageProgress";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptimizeImageProgress;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptimizeImageProgress;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptimizeImageProgress;

  static equals(a: OptimizeImageProgress | PlainMessage<OptimizeImageProgress> | undefined, b: OptimizeImageProgress | PlainMessage<OptimizeImageProgress> | undefined): boolean;
}

/**
 * @generated from enum namespace.cloud.compute.v1beta.OptimizeImageProgress.Status
 */
export declare enum OptimizeImageProgress_Status {
  /**
   * @generated from enum value: STATUS_UNKNOWN = 0;
   */
  STATUS_UNKNOWN = 0,

  /**
   * @generated from enum value: PREPARING = 1;
   */
  PREPARING = 1,

  /**
   * @generated from enum value: STARTING = 2;
   */
  STARTING = 2,

  /**
   * @generated from enum value: BAKING = 3;
   */
  BAKING = 3,

  /**
   * @generated from enum value: DONE = 4;
   */
  DONE = 4,
}

/**
 * @generated from message namespace.cloud.compute.v1beta.InstanceEventMetadata
 */
export declare class InstanceEventMetadata extends Message<InstanceEventMetadata> {
  /**
   * @generated from field: google.protobuf.Timestamp emitted_at = 1;
   */
  emittedAt?: Timestamp;

  /**
   * @generated from field: string tenant_id = 2;
   */
  tenantId: string;

  /**
   * @generated from field: string instance_id = 3;
   */
  instanceId: string;

  /**
   * @generated from field: namespace.cloud.compute.v1beta.InstanceMetadata.Status status = 4;
   */
  status: InstanceMetadata_Status;

  /**
   * @generated from field: repeated namespace.stdlib.Label labels = 5;
   */
  labels: Label[];

  constructor(data?: PartialMessage<InstanceEventMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.InstanceEventMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceEventMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceEventMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceEventMetadata;

  static equals(a: InstanceEventMetadata | PlainMessage<InstanceEventMetadata> | undefined, b: InstanceEventMetadata | PlainMessage<InstanceEventMetadata> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListInstanceNotificationsRequest
 */
export declare class ListInstanceNotificationsRequest extends Message<ListInstanceNotificationsRequest> {
  /**
   * Optional filter to match instance IDs. If not set, returns events for
   * all instances.
   *
   * @generated from field: namespace.stdlib.StringMatcher instance_ids = 1;
   */
  instanceIds?: StringMatcher;

  /**
   * The maximum number of events to return. The list of events returned is
   * always capped to an internal number.
   *
   * @generated from field: int64 limit = 2;
   */
  limit: bigint;

  /**
   * If set to true, only pending events that have not yet been delivered
   * are returned.
   *
   * @generated from field: bool only_pending_events = 3;
   */
  onlyPendingEvents: boolean;

  constructor(data?: PartialMessage<ListInstanceNotificationsRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListInstanceNotificationsRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInstanceNotificationsRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInstanceNotificationsRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInstanceNotificationsRequest;

  static equals(a: ListInstanceNotificationsRequest | PlainMessage<ListInstanceNotificationsRequest> | undefined, b: ListInstanceNotificationsRequest | PlainMessage<ListInstanceNotificationsRequest> | undefined): boolean;
}

/**
 * @generated from message namespace.cloud.compute.v1beta.ListInstanceNotificationsResponse
 */
export declare class ListInstanceNotificationsResponse extends Message<ListInstanceNotificationsResponse> {
  /**
   * The list of events, ordered by emitted time in descending order (most
   * recent first). Each instance has at most one event in the response.
   *
   * @generated from field: repeated namespace.cloud.compute.v1beta.InstanceEventMetadata events = 1;
   */
  events: InstanceEventMetadata[];

  constructor(data?: PartialMessage<ListInstanceNotificationsResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "namespace.cloud.compute.v1beta.ListInstanceNotificationsResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInstanceNotificationsResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInstanceNotificationsResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInstanceNotificationsResponse;

  static equals(a: ListInstanceNotificationsResponse | PlainMessage<ListInstanceNotificationsResponse> | undefined, b: ListInstanceNotificationsResponse | PlainMessage<ListInstanceNotificationsResponse> | undefined): boolean;
}

