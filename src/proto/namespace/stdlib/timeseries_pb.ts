// @generated by protoc-gen-es v1.3.0 with parameter "target=js+ts+dts"
// @generated from file proto/namespace/stdlib/timeseries.proto (package namespace.stdlib, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Represents a time series of data, associating multiple string-keyed data
 * points to each timestamp.
 *
 * Each data point N has a timestamp stored in timestamps[N].
 * Data associated with that timestamp is then stored in:
 * - doubles[key].values[N] if the data is represented as a double
 * - integers[key].values[N] if the data is represented as a int64
 * - strings[key].values[N] if the data is represented as a string
 *
 * The API that returns a TimeSeries describes which keys will be present.
 *
 * @generated from message namespace.stdlib.TimeSeries
 */
export class TimeSeries extends Message<TimeSeries> {
  /**
   * timestamps are represented as the number of nanoseconds elapsed since
   * January 1, 1970 UTC.
   *
   * @generated from field: repeated int64 timestamps = 1;
   */
  timestamps: bigint[] = [];

  /**
   * @generated from field: map<string, namespace.stdlib.TimeSeries.Doubles> doubles = 2;
   */
  doubles: { [key: string]: TimeSeries_Doubles } = {};

  /**
   * @generated from field: map<string, namespace.stdlib.TimeSeries.Integers> integers = 3;
   */
  integers: { [key: string]: TimeSeries_Integers } = {};

  /**
   * @generated from field: map<string, namespace.stdlib.TimeSeries.Strings> strings = 4;
   */
  strings: { [key: string]: TimeSeries_Strings } = {};

  constructor(data?: PartialMessage<TimeSeries>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.stdlib.TimeSeries";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamps", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 2, name: "doubles", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: TimeSeries_Doubles} },
    { no: 3, name: "integers", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: TimeSeries_Integers} },
    { no: 4, name: "strings", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: TimeSeries_Strings} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeries {
    return new TimeSeries().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeries {
    return new TimeSeries().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeries {
    return new TimeSeries().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeries | PlainMessage<TimeSeries> | undefined, b: TimeSeries | PlainMessage<TimeSeries> | undefined): boolean {
    return proto3.util.equals(TimeSeries, a, b);
  }
}

/**
 * @generated from message namespace.stdlib.TimeSeries.Doubles
 */
export class TimeSeries_Doubles extends Message<TimeSeries_Doubles> {
  /**
   * @generated from field: repeated double values = 1;
   */
  values: number[] = [];

  constructor(data?: PartialMessage<TimeSeries_Doubles>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.stdlib.TimeSeries.Doubles";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeries_Doubles {
    return new TimeSeries_Doubles().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeries_Doubles {
    return new TimeSeries_Doubles().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeries_Doubles {
    return new TimeSeries_Doubles().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeries_Doubles | PlainMessage<TimeSeries_Doubles> | undefined, b: TimeSeries_Doubles | PlainMessage<TimeSeries_Doubles> | undefined): boolean {
    return proto3.util.equals(TimeSeries_Doubles, a, b);
  }
}

/**
 * @generated from message namespace.stdlib.TimeSeries.Integers
 */
export class TimeSeries_Integers extends Message<TimeSeries_Integers> {
  /**
   * @generated from field: repeated int64 values = 1;
   */
  values: bigint[] = [];

  constructor(data?: PartialMessage<TimeSeries_Integers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.stdlib.TimeSeries.Integers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeries_Integers {
    return new TimeSeries_Integers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeries_Integers {
    return new TimeSeries_Integers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeries_Integers {
    return new TimeSeries_Integers().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeries_Integers | PlainMessage<TimeSeries_Integers> | undefined, b: TimeSeries_Integers | PlainMessage<TimeSeries_Integers> | undefined): boolean {
    return proto3.util.equals(TimeSeries_Integers, a, b);
  }
}

/**
 * @generated from message namespace.stdlib.TimeSeries.Strings
 */
export class TimeSeries_Strings extends Message<TimeSeries_Strings> {
  /**
   * @generated from field: repeated string values = 1;
   */
  values: string[] = [];

  constructor(data?: PartialMessage<TimeSeries_Strings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "namespace.stdlib.TimeSeries.Strings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeries_Strings {
    return new TimeSeries_Strings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeries_Strings {
    return new TimeSeries_Strings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeries_Strings {
    return new TimeSeries_Strings().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeries_Strings | PlainMessage<TimeSeries_Strings> | undefined, b: TimeSeries_Strings | PlainMessage<TimeSeries_Strings> | undefined): boolean {
    return proto3.util.equals(TimeSeries_Strings, a, b);
  }
}

